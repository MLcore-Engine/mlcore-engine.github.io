<!DOCTYPE html>
<html lang="zh-cn">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<title>Linux Common - 高新 | AI平台开发工程师</title>
<meta name="description" content="AI平台开发工程师，专注于AI平台工程和Kubernetes云原生技术。拥有AI平台开发、GPU资源优化和AI服务部署经验">
<meta name="generator" content="Hugo 0.145.0">
<link href="http://localhost:1313//index.xml" rel="alternate" type="application/rss+xml">
<link rel="canonical" href="http://localhost:1313/linux_foundation/linux-common/">
<link rel="stylesheet" href="http://localhost:1313/css/theme.min.css">
<link rel="stylesheet" href="http://localhost:1313/css/chroma.min.css">
<script defer src="http://localhost:1313//js/fontawesome6/all.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js" integrity="sha256-H3cjtrm/ztDeuhCN9I4yh4iN2Ybx/y1RM7rMmAesA0k=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js" integrity="sha256-4XodgW4TwIJuDtf+v6vDJ39FVxI0veC/kSCCmnFp7ck=" crossorigin="anonymous"></script>
<script src="http://localhost:1313/js/bundle.js"></script><style>
 
@media screen and (min-width: 480px) {
  .sidebar {
    flex: 0 0 20% !important;
    max-width: 20% !important;
  }
  
  main {
    flex: 0 0 80% !important;
    max-width: 80% !important;
  }
}

 
body {
  background-color: #f8f5e6 !important;  
  font-family: 'KaiTi', 'STKaiti', '楷体', '楷体_GB2312', 'SimKai', '华文楷体', Kai, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif !important;  
  font-size: 20px !important;  
  line-height: 1.8 !important;  
}

 
.container, .content-container, main {
  background-color: #f8f5e6 !important;
}

 
.sidebar {
  background-color: inherit;
  font-size: 16px !important;  
}

 
h1, h2, h3, h4, h5, h6 {
  font-family: 'KaiTi', 'STKaiti', '楷体', '楷体_GB2312', 'SimKai', '华文楷体', Kai, 'Noto Serif', Georgia, serif !important;
  font-weight: 600 !important;
  line-height: 1.5 !important;
}

 
h1 {
  font-size: 2.4em !important;
}

h2 {
  font-size: 2em !important;
}

h3 {
  font-size: 1.7em !important;
}

h4 {
  font-size: 1.5em !important;
}

h5 {
  font-size: 1.3em !important;
}

h6 {
  font-size: 1.2em !important;
}

 
p {
  font-size: 20px !important;
  margin-bottom: 1.2em !important;
}

 
li {
  font-size: 20px !important;
  margin-bottom: 0.5em !important;
}

 
article, .content, .post-content, main p, main li, main td, main th, blockquote, .markdown {
  font-size: 20px !important;
}

 
pre, code {
  font-family: 'JetBrains Mono', Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace !important;
  font-size: 1.1em !important;  
}

 
a {
  color: #0066cc !important;
  text-decoration: none !important;
}

a:hover {
  text-decoration: underline !important;
}

 
table {
  font-size: 20px !important;
}
</style> <meta property="og:url" content="http://localhost:1313/linux_foundation/linux-common/">
  <meta property="og:site_name" content="高新 | AI平台开发工程师">
  <meta property="og:title" content="Linux Common">
  <meta property="og:description" content="0.配置阿里yum源 #配置阿里yum源命令 curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo curl -o /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo #运行以下命令生成缓存 yum clean all yum makecache 2.查看系统版本 #查看系统发行版本 lsb_release -a cat /etc/redhat-release #查看linux内核版本 uname -a 3.centos中的tmpfs #是一种临时文件系统，它将一部分系统内存用作虚拟文件系统，用于临时存储数据。tmpfs 的作用是提供一个基于内存的文件系统，可以用来存储临时文件、缓存数据、临时运行时文件等，从而在许多情况下提高性能和效率。 /dev/shm #包含共享内存分配 /run #用于系统日志 /sys/fs/cgroup #用于cgroup 一个针对特定进程限制 管理和审计资源利用的内核特性 #你可以使用systemctl命令在tmp目录启用tmpfs， 首先用下面的命令来检查这个特性是否可用： systemctl is-enabled tmp.mount #这会显示当先的状态，（如果未启用，）你可以使用下面的命令来启用它： systemctl enable tmp.mount #可以在/etc/fstab中添加下面这行，来手工在/tmp下挂载 tmpfs tmpfs /tmp tmpfs size=512m 0 0 4.mount命令用法和问题 mount用法 挂载方法： mount Device MOUNT_POINT -t vsftype: 指定要挂载的设备上的文件系统类型 -r readonly : 只读挂载 -w read and write: 读写挂载 -L :以卷标指定挂载设备 -U : 以uuid指定要挂载的设备 -B --bind : 绑定目录到另一个目录上 #卸载命令umount umount DEVICE umount MOUNT_POINT #重新挂载命令 mount -o remount /dev/shm #当加入一块新设备时 1.要对设备进行格式化（制作文件系统） 2. 将其挂载到指定目录 #格式化 mkfs -t ext4 /dev/sdb #挂载 mount /dev/sdb /xxx/ #进阶版 $ mount sysfs on /sys type sysfs (rw,nosuid,nodev,noexec,relatime,seclabel) #输出信息的格式和含义 fs_spec on fs_file type fs_vfstype (fs_mntopts) fs_spec:挂载的块设备或者远程文件系统 fs_file:文件系统的挂载点 fs_vfstype:文件系统的类型 fs_mntopts:与文件系统的相关选项 第一行的含义:挂载的设备是sysfs 挂载点是/sys 文件系统的类型是sysfs 括号中rw代表可读写的方式挂载文件系统 noexec表示不能再该文件系统上直接运行程序 overlay mkdir layer1 layer2 mkdir ./rootfs/{merged,diff,work} -p mount -t overlay overlay -o lowerdir=./layer1:./layer2,upperdir=./rootfs/diff,workdir=./rootfs/work ./rootfs/merged merged:挂载点 diff: upper work: work #问题描述 #当创建一个新的进程并且挂载proc时，退出后在终端执行命令 mount 会出现下面的错误 mount: failed to read mtab: No such file or directory #解决办法 执行下边的命令 就可以在终端执行mount命令了 mount -t proc proc /proc 5.几个常用的关机命令 halt: 关机但不关闭电源（加p参数关闭电源）不加参数时调用shutdown命令 halt -p 相当于poweroff halt -f 强制关机 halt -i 关机或重启前关闭所有网络接口 shutdown实际上是调用init 0, init 0会cleanup一些工作然后调用halt或者poweroff。其实主要区别是halt和poweroff，在没有acpi的系统上，halt只是关闭了os，电源还在工作，你得手动取按一下那个按钮，而poweroff会发送一个关闭电源的信号给acpi。但在现在的系统上，他们实际上都一样了 6.lsblk命令 lsblk可以列出所有可用块设备的信息。比如逻辑磁盘，而df -h 是查看文件系统级别的信息 NAME: 块设备的名称。 MAJ:MIN: 主设备号和次设备号，用于唯一标识设备。 RM: 可移除性标志，0 表示设备不可移除，1 表示设备可移除。 SIZE: 设备的总大小。 RO: 只读标志，0 表示设备可读写，1 表示设备只读。 TYPE: 设备的类型，如 disk 表示硬盘，part 表示分区，rom 表示只读光盘等。 MOUNTPOINT: 如果设备已挂载，显示挂载点；如果未挂载，该字段为空。 7.快捷键 1.ctrl&#43;a #光标回到行首 2.ctrl&#43;e #光标回到行尾 3.ctrl&#43;w #移除光标前的一个单词 4.Ctrl&#43;k #删除光标处到行尾的字符 5.Ctrl&#43;y #粘贴Ctrl&#43;u，Ctrl&#43;k，Ctrl&#43;w删除的文本 6.Esc&#43;b #移动到当前单词的开头 7.Esc&#43;f #移动到当前单词的结尾 8.Ctrl&#43;d #向行尾删除一个字符 8. snat dnat MASQUERADE https://www.cnblogs.com/Dicky-Zhang/p/5934657.html">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="linux_foundation">
    <meta property="article:published_time" content="2025-04-03T13:50:45+08:00">
    <meta property="article:modified_time" content="2025-04-17T13:08:49+08:00">
    <meta property="og:image" content="http://localhost:1313/home/me.png">

  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:image" content="http://localhost:1313/home/me.png">
  <meta name="twitter:title" content="Linux Common">
  <meta name="twitter:description" content="0.配置阿里yum源 #配置阿里yum源命令 curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo curl -o /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo #运行以下命令生成缓存 yum clean all yum makecache 2.查看系统版本 #查看系统发行版本 lsb_release -a cat /etc/redhat-release #查看linux内核版本 uname -a 3.centos中的tmpfs #是一种临时文件系统，它将一部分系统内存用作虚拟文件系统，用于临时存储数据。tmpfs 的作用是提供一个基于内存的文件系统，可以用来存储临时文件、缓存数据、临时运行时文件等，从而在许多情况下提高性能和效率。 /dev/shm #包含共享内存分配 /run #用于系统日志 /sys/fs/cgroup #用于cgroup 一个针对特定进程限制 管理和审计资源利用的内核特性 #你可以使用systemctl命令在tmp目录启用tmpfs， 首先用下面的命令来检查这个特性是否可用： systemctl is-enabled tmp.mount #这会显示当先的状态，（如果未启用，）你可以使用下面的命令来启用它： systemctl enable tmp.mount #可以在/etc/fstab中添加下面这行，来手工在/tmp下挂载 tmpfs tmpfs /tmp tmpfs size=512m 0 0 4.mount命令用法和问题 mount用法 挂载方法： mount Device MOUNT_POINT -t vsftype: 指定要挂载的设备上的文件系统类型 -r readonly : 只读挂载 -w read and write: 读写挂载 -L :以卷标指定挂载设备 -U : 以uuid指定要挂载的设备 -B --bind : 绑定目录到另一个目录上 #卸载命令umount umount DEVICE umount MOUNT_POINT #重新挂载命令 mount -o remount /dev/shm #当加入一块新设备时 1.要对设备进行格式化（制作文件系统） 2. 将其挂载到指定目录 #格式化 mkfs -t ext4 /dev/sdb #挂载 mount /dev/sdb /xxx/ #进阶版 $ mount sysfs on /sys type sysfs (rw,nosuid,nodev,noexec,relatime,seclabel) #输出信息的格式和含义 fs_spec on fs_file type fs_vfstype (fs_mntopts) fs_spec:挂载的块设备或者远程文件系统 fs_file:文件系统的挂载点 fs_vfstype:文件系统的类型 fs_mntopts:与文件系统的相关选项 第一行的含义:挂载的设备是sysfs 挂载点是/sys 文件系统的类型是sysfs 括号中rw代表可读写的方式挂载文件系统 noexec表示不能再该文件系统上直接运行程序 overlay mkdir layer1 layer2 mkdir ./rootfs/{merged,diff,work} -p mount -t overlay overlay -o lowerdir=./layer1:./layer2,upperdir=./rootfs/diff,workdir=./rootfs/work ./rootfs/merged merged:挂载点 diff: upper work: work #问题描述 #当创建一个新的进程并且挂载proc时，退出后在终端执行命令 mount 会出现下面的错误 mount: failed to read mtab: No such file or directory #解决办法 执行下边的命令 就可以在终端执行mount命令了 mount -t proc proc /proc 5.几个常用的关机命令 halt: 关机但不关闭电源（加p参数关闭电源）不加参数时调用shutdown命令 halt -p 相当于poweroff halt -f 强制关机 halt -i 关机或重启前关闭所有网络接口 shutdown实际上是调用init 0, init 0会cleanup一些工作然后调用halt或者poweroff。其实主要区别是halt和poweroff，在没有acpi的系统上，halt只是关闭了os，电源还在工作，你得手动取按一下那个按钮，而poweroff会发送一个关闭电源的信号给acpi。但在现在的系统上，他们实际上都一样了 6.lsblk命令 lsblk可以列出所有可用块设备的信息。比如逻辑磁盘，而df -h 是查看文件系统级别的信息 NAME: 块设备的名称。 MAJ:MIN: 主设备号和次设备号，用于唯一标识设备。 RM: 可移除性标志，0 表示设备不可移除，1 表示设备可移除。 SIZE: 设备的总大小。 RO: 只读标志，0 表示设备可读写，1 表示设备只读。 TYPE: 设备的类型，如 disk 表示硬盘，part 表示分区，rom 表示只读光盘等。 MOUNTPOINT: 如果设备已挂载，显示挂载点；如果未挂载，该字段为空。 7.快捷键 1.ctrl&#43;a #光标回到行首 2.ctrl&#43;e #光标回到行尾 3.ctrl&#43;w #移除光标前的一个单词 4.Ctrl&#43;k #删除光标处到行尾的字符 5.Ctrl&#43;y #粘贴Ctrl&#43;u，Ctrl&#43;k，Ctrl&#43;w删除的文本 6.Esc&#43;b #移动到当前单词的开头 7.Esc&#43;f #移动到当前单词的结尾 8.Ctrl&#43;d #向行尾删除一个字符 8. snat dnat MASQUERADE https://www.cnblogs.com/Dicky-Zhang/p/5934657.html">

  <meta itemprop="name" content="Linux Common">
  <meta itemprop="description" content="0.配置阿里yum源 #配置阿里yum源命令 curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo curl -o /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo #运行以下命令生成缓存 yum clean all yum makecache 2.查看系统版本 #查看系统发行版本 lsb_release -a cat /etc/redhat-release #查看linux内核版本 uname -a 3.centos中的tmpfs #是一种临时文件系统，它将一部分系统内存用作虚拟文件系统，用于临时存储数据。tmpfs 的作用是提供一个基于内存的文件系统，可以用来存储临时文件、缓存数据、临时运行时文件等，从而在许多情况下提高性能和效率。 /dev/shm #包含共享内存分配 /run #用于系统日志 /sys/fs/cgroup #用于cgroup 一个针对特定进程限制 管理和审计资源利用的内核特性 #你可以使用systemctl命令在tmp目录启用tmpfs， 首先用下面的命令来检查这个特性是否可用： systemctl is-enabled tmp.mount #这会显示当先的状态，（如果未启用，）你可以使用下面的命令来启用它： systemctl enable tmp.mount #可以在/etc/fstab中添加下面这行，来手工在/tmp下挂载 tmpfs tmpfs /tmp tmpfs size=512m 0 0 4.mount命令用法和问题 mount用法 挂载方法： mount Device MOUNT_POINT -t vsftype: 指定要挂载的设备上的文件系统类型 -r readonly : 只读挂载 -w read and write: 读写挂载 -L :以卷标指定挂载设备 -U : 以uuid指定要挂载的设备 -B --bind : 绑定目录到另一个目录上 #卸载命令umount umount DEVICE umount MOUNT_POINT #重新挂载命令 mount -o remount /dev/shm #当加入一块新设备时 1.要对设备进行格式化（制作文件系统） 2. 将其挂载到指定目录 #格式化 mkfs -t ext4 /dev/sdb #挂载 mount /dev/sdb /xxx/ #进阶版 $ mount sysfs on /sys type sysfs (rw,nosuid,nodev,noexec,relatime,seclabel) #输出信息的格式和含义 fs_spec on fs_file type fs_vfstype (fs_mntopts) fs_spec:挂载的块设备或者远程文件系统 fs_file:文件系统的挂载点 fs_vfstype:文件系统的类型 fs_mntopts:与文件系统的相关选项 第一行的含义:挂载的设备是sysfs 挂载点是/sys 文件系统的类型是sysfs 括号中rw代表可读写的方式挂载文件系统 noexec表示不能再该文件系统上直接运行程序 overlay mkdir layer1 layer2 mkdir ./rootfs/{merged,diff,work} -p mount -t overlay overlay -o lowerdir=./layer1:./layer2,upperdir=./rootfs/diff,workdir=./rootfs/work ./rootfs/merged merged:挂载点 diff: upper work: work #问题描述 #当创建一个新的进程并且挂载proc时，退出后在终端执行命令 mount 会出现下面的错误 mount: failed to read mtab: No such file or directory #解决办法 执行下边的命令 就可以在终端执行mount命令了 mount -t proc proc /proc 5.几个常用的关机命令 halt: 关机但不关闭电源（加p参数关闭电源）不加参数时调用shutdown命令 halt -p 相当于poweroff halt -f 强制关机 halt -i 关机或重启前关闭所有网络接口 shutdown实际上是调用init 0, init 0会cleanup一些工作然后调用halt或者poweroff。其实主要区别是halt和poweroff，在没有acpi的系统上，halt只是关闭了os，电源还在工作，你得手动取按一下那个按钮，而poweroff会发送一个关闭电源的信号给acpi。但在现在的系统上，他们实际上都一样了 6.lsblk命令 lsblk可以列出所有可用块设备的信息。比如逻辑磁盘，而df -h 是查看文件系统级别的信息 NAME: 块设备的名称。 MAJ:MIN: 主设备号和次设备号，用于唯一标识设备。 RM: 可移除性标志，0 表示设备不可移除，1 表示设备可移除。 SIZE: 设备的总大小。 RO: 只读标志，0 表示设备可读写，1 表示设备只读。 TYPE: 设备的类型，如 disk 表示硬盘，part 表示分区，rom 表示只读光盘等。 MOUNTPOINT: 如果设备已挂载，显示挂载点；如果未挂载，该字段为空。 7.快捷键 1.ctrl&#43;a #光标回到行首 2.ctrl&#43;e #光标回到行尾 3.ctrl&#43;w #移除光标前的一个单词 4.Ctrl&#43;k #删除光标处到行尾的字符 5.Ctrl&#43;y #粘贴Ctrl&#43;u，Ctrl&#43;k，Ctrl&#43;w删除的文本 6.Esc&#43;b #移动到当前单词的开头 7.Esc&#43;f #移动到当前单词的结尾 8.Ctrl&#43;d #向行尾删除一个字符 8. snat dnat MASQUERADE https://www.cnblogs.com/Dicky-Zhang/p/5934657.html">
  <meta itemprop="datePublished" content="2025-04-03T13:50:45+08:00">
  <meta itemprop="dateModified" content="2025-04-17T13:08:49+08:00">
  <meta itemprop="wordCount" content="12597">
  <meta itemprop="image" content="http://localhost:1313/home/me.png">
<link rel="apple-touch-icon" sizes="180x180" href="/favicon/favicon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png">
<link rel="manifest" href="/favicon/site.webmanifest">
<link rel="mask-icon" href="/favicon/safari-pinned-tab.svg" color="#5bbad5">
<link rel="shortcut icon" href="/favicon.ico">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="msapplication-config" content="/favicon/browserconfig.xml">
<meta name="theme-color" content="#ffffff"> 


<meta name="description" content="0.配置阿里yum源 #配置阿里yum源命令 curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo curl -o /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo #运行以下命令生成缓存 yum clean all yum makecache 2.查看系统版本 #查看系统发行版本 lsb_release -a cat /etc/redhat-release #查看linux内核版本 uname -a 3.centos中的tmpfs #是一种临时文件系统，它将一部分系统内存用作虚拟文件系统，用于临时存储数据。tmpfs 的作用是提供一个基于内存的文件系统，可以用来存储临时文件、缓存数据、临时运行时文件等，从而在许多情况下提高性能和效率。 /dev/shm #包含共享内存分配 /run #用于系统日志 /sys/fs/cgroup #用于cgroup 一个针对特定进程限制 管理和审计资源利用的内核特性 #你可以使用systemctl命令在tmp目录启用tmpfs， 首先用下面的命令来检查这个特性是否可用： systemctl is-enabled tmp.mount #这会显示当先的状态，（如果未启用，）你可以使用下面的命令来启用它： systemctl enable tmp.mount #可以在/etc/fstab中添加下面这行，来手工在/tmp下挂载 tmpfs tmpfs /tmp tmpfs size=512m 0 0 4.mount命令用法和问题 mount用法 挂载方法： mount Device MOUNT_POINT -t vsftype: 指定要挂载的设备上的文件系统类型 -r readonly : 只读挂载 -w read and write: 读写挂载 -L :以卷标指定挂载设备 -U : 以uuid指定要挂载的设备 -B --bind : 绑定目录到另一个目录上 #卸载命令umount umount DEVICE umount MOUNT_POINT #重新挂载命令 mount -o remount /dev/shm #当加入一块新设备时 1.要对设备进行格式化（制作文件系统） 2. 将其挂载到指定目录 #格式化 mkfs -t ext4 /dev/sdb #挂载 mount /dev/sdb /xxx/ #进阶版 $ mount sysfs on /sys type sysfs (rw,nosuid,nodev,noexec,relatime,seclabel) #输出信息的格式和含义 fs_spec on fs_file type fs_vfstype (fs_mntopts) fs_spec:挂载的块设备或者远程文件系统 fs_file:文件系统的挂载点 fs_vfstype:文件系统的类型 fs_mntopts:与文件系统的相关选项 第一行的含义:挂载的设备是sysfs 挂载点是/sys 文件系统的类型是sysfs 括号中rw代表可读写的方式挂载文件系统 noexec表示不能再该文件系统上直接运行程序 overlay mkdir layer1 layer2 mkdir ./rootfs/{merged,diff,work} -p mount -t overlay overlay -o lowerdir=./layer1:./layer2,upperdir=./rootfs/diff,workdir=./rootfs/work ./rootfs/merged merged:挂载点 diff: upper work: work #问题描述 #当创建一个新的进程并且挂载proc时，退出后在终端执行命令 mount 会出现下面的错误 mount: failed to read mtab: No such file or directory #解决办法 执行下边的命令 就可以在终端执行mount命令了 mount -t proc proc /proc 5.几个常用的关机命令 halt: 关机但不关闭电源（加p参数关闭电源）不加参数时调用shutdown命令 halt -p 相当于poweroff halt -f 强制关机 halt -i 关机或重启前关闭所有网络接口 shutdown实际上是调用init 0, init 0会cleanup一些工作然后调用halt或者poweroff。其实主要区别是halt和poweroff，在没有acpi的系统上，halt只是关闭了os，电源还在工作，你得手动取按一下那个按钮，而poweroff会发送一个关闭电源的信号给acpi。但在现在的系统上，他们实际上都一样了 6.lsblk命令 lsblk可以列出所有可用块设备的信息。比如逻辑磁盘，而df -h 是查看文件系统级别的信息 NAME: 块设备的名称。 MAJ:MIN: 主设备号和次设备号，用于唯一标识设备。 RM: 可移除性标志，0 表示设备不可移除，1 表示设备可移除。 SIZE: 设备的总大小。 RO: 只读标志，0 表示设备可读写，1 表示设备只读。 TYPE: 设备的类型，如 disk 表示硬盘，part 表示分区，rom 表示只读光盘等。 MOUNTPOINT: 如果设备已挂载，显示挂载点；如果未挂载，该字段为空。 7.快捷键 1.ctrl&#43;a #光标回到行首 2.ctrl&#43;e #光标回到行尾 3.ctrl&#43;w #移除光标前的一个单词 4.Ctrl&#43;k #删除光标处到行尾的字符 5.Ctrl&#43;y #粘贴Ctrl&#43;u，Ctrl&#43;k，Ctrl&#43;w删除的文本 6.Esc&#43;b #移动到当前单词的开头 7.Esc&#43;f #移动到当前单词的结尾 8.Ctrl&#43;d #向行尾删除一个字符 8. snat dnat MASQUERADE https://www.cnblogs.com/Dicky-Zhang/p/5934657.html
">
<meta name="keywords" content="AI, 机器学习, golang, kubernetes, 技术博客">
<meta name="author" content="高新">


<meta property="og:type" content="article">
<meta property="og:url" content="http://localhost:1313/linux_foundation/linux-common/">
<meta property="og:title" content="Linux Common | 高新 | AI平台开发工程师">
<meta property="og:description" content="0.配置阿里yum源 #配置阿里yum源命令 curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo curl -o /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo #运行以下命令生成缓存 yum clean all yum makecache 2.查看系统版本 #查看系统发行版本 lsb_release -a cat /etc/redhat-release #查看linux内核版本 uname -a 3.centos中的tmpfs #是一种临时文件系统，它将一部分系统内存用作虚拟文件系统，用于临时存储数据。tmpfs 的作用是提供一个基于内存的文件系统，可以用来存储临时文件、缓存数据、临时运行时文件等，从而在许多情况下提高性能和效率。 /dev/shm #包含共享内存分配 /run #用于系统日志 /sys/fs/cgroup #用于cgroup 一个针对特定进程限制 管理和审计资源利用的内核特性 #你可以使用systemctl命令在tmp目录启用tmpfs， 首先用下面的命令来检查这个特性是否可用： systemctl is-enabled tmp.mount #这会显示当先的状态，（如果未启用，）你可以使用下面的命令来启用它： systemctl enable tmp.mount #可以在/etc/fstab中添加下面这行，来手工在/tmp下挂载 tmpfs tmpfs /tmp tmpfs size=512m 0 0 4.mount命令用法和问题 mount用法 挂载方法： mount Device MOUNT_POINT -t vsftype: 指定要挂载的设备上的文件系统类型 -r readonly : 只读挂载 -w read and write: 读写挂载 -L :以卷标指定挂载设备 -U : 以uuid指定要挂载的设备 -B --bind : 绑定目录到另一个目录上 #卸载命令umount umount DEVICE umount MOUNT_POINT #重新挂载命令 mount -o remount /dev/shm #当加入一块新设备时 1.要对设备进行格式化（制作文件系统） 2. 将其挂载到指定目录 #格式化 mkfs -t ext4 /dev/sdb #挂载 mount /dev/sdb /xxx/ #进阶版 $ mount sysfs on /sys type sysfs (rw,nosuid,nodev,noexec,relatime,seclabel) #输出信息的格式和含义 fs_spec on fs_file type fs_vfstype (fs_mntopts) fs_spec:挂载的块设备或者远程文件系统 fs_file:文件系统的挂载点 fs_vfstype:文件系统的类型 fs_mntopts:与文件系统的相关选项 第一行的含义:挂载的设备是sysfs 挂载点是/sys 文件系统的类型是sysfs 括号中rw代表可读写的方式挂载文件系统 noexec表示不能再该文件系统上直接运行程序 overlay mkdir layer1 layer2 mkdir ./rootfs/{merged,diff,work} -p mount -t overlay overlay -o lowerdir=./layer1:./layer2,upperdir=./rootfs/diff,workdir=./rootfs/work ./rootfs/merged merged:挂载点 diff: upper work: work #问题描述 #当创建一个新的进程并且挂载proc时，退出后在终端执行命令 mount 会出现下面的错误 mount: failed to read mtab: No such file or directory #解决办法 执行下边的命令 就可以在终端执行mount命令了 mount -t proc proc /proc 5.几个常用的关机命令 halt: 关机但不关闭电源（加p参数关闭电源）不加参数时调用shutdown命令 halt -p 相当于poweroff halt -f 强制关机 halt -i 关机或重启前关闭所有网络接口 shutdown实际上是调用init 0, init 0会cleanup一些工作然后调用halt或者poweroff。其实主要区别是halt和poweroff，在没有acpi的系统上，halt只是关闭了os，电源还在工作，你得手动取按一下那个按钮，而poweroff会发送一个关闭电源的信号给acpi。但在现在的系统上，他们实际上都一样了 6.lsblk命令 lsblk可以列出所有可用块设备的信息。比如逻辑磁盘，而df -h 是查看文件系统级别的信息 NAME: 块设备的名称。 MAJ:MIN: 主设备号和次设备号，用于唯一标识设备。 RM: 可移除性标志，0 表示设备不可移除，1 表示设备可移除。 SIZE: 设备的总大小。 RO: 只读标志，0 表示设备可读写，1 表示设备只读。 TYPE: 设备的类型，如 disk 表示硬盘，part 表示分区，rom 表示只读光盘等。 MOUNTPOINT: 如果设备已挂载，显示挂载点；如果未挂载，该字段为空。 7.快捷键 1.ctrl&#43;a #光标回到行首 2.ctrl&#43;e #光标回到行尾 3.ctrl&#43;w #移除光标前的一个单词 4.Ctrl&#43;k #删除光标处到行尾的字符 5.Ctrl&#43;y #粘贴Ctrl&#43;u，Ctrl&#43;k，Ctrl&#43;w删除的文本 6.Esc&#43;b #移动到当前单词的开头 7.Esc&#43;f #移动到当前单词的结尾 8.Ctrl&#43;d #向行尾删除一个字符 8. snat dnat MASQUERADE https://www.cnblogs.com/Dicky-Zhang/p/5934657.html
">
<meta property="og:image" content="http://localhost:1313/home/me.png">


<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:url" content="http://localhost:1313/linux_foundation/linux-common/">
<meta name="twitter:title" content="Linux Common | 高新 | AI平台开发工程师">
<meta name="twitter:description" content="0.配置阿里yum源 #配置阿里yum源命令 curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo curl -o /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo #运行以下命令生成缓存 yum clean all yum makecache 2.查看系统版本 #查看系统发行版本 lsb_release -a cat /etc/redhat-release #查看linux内核版本 uname -a 3.centos中的tmpfs #是一种临时文件系统，它将一部分系统内存用作虚拟文件系统，用于临时存储数据。tmpfs 的作用是提供一个基于内存的文件系统，可以用来存储临时文件、缓存数据、临时运行时文件等，从而在许多情况下提高性能和效率。 /dev/shm #包含共享内存分配 /run #用于系统日志 /sys/fs/cgroup #用于cgroup 一个针对特定进程限制 管理和审计资源利用的内核特性 #你可以使用systemctl命令在tmp目录启用tmpfs， 首先用下面的命令来检查这个特性是否可用： systemctl is-enabled tmp.mount #这会显示当先的状态，（如果未启用，）你可以使用下面的命令来启用它： systemctl enable tmp.mount #可以在/etc/fstab中添加下面这行，来手工在/tmp下挂载 tmpfs tmpfs /tmp tmpfs size=512m 0 0 4.mount命令用法和问题 mount用法 挂载方法： mount Device MOUNT_POINT -t vsftype: 指定要挂载的设备上的文件系统类型 -r readonly : 只读挂载 -w read and write: 读写挂载 -L :以卷标指定挂载设备 -U : 以uuid指定要挂载的设备 -B --bind : 绑定目录到另一个目录上 #卸载命令umount umount DEVICE umount MOUNT_POINT #重新挂载命令 mount -o remount /dev/shm #当加入一块新设备时 1.要对设备进行格式化（制作文件系统） 2. 将其挂载到指定目录 #格式化 mkfs -t ext4 /dev/sdb #挂载 mount /dev/sdb /xxx/ #进阶版 $ mount sysfs on /sys type sysfs (rw,nosuid,nodev,noexec,relatime,seclabel) #输出信息的格式和含义 fs_spec on fs_file type fs_vfstype (fs_mntopts) fs_spec:挂载的块设备或者远程文件系统 fs_file:文件系统的挂载点 fs_vfstype:文件系统的类型 fs_mntopts:与文件系统的相关选项 第一行的含义:挂载的设备是sysfs 挂载点是/sys 文件系统的类型是sysfs 括号中rw代表可读写的方式挂载文件系统 noexec表示不能再该文件系统上直接运行程序 overlay mkdir layer1 layer2 mkdir ./rootfs/{merged,diff,work} -p mount -t overlay overlay -o lowerdir=./layer1:./layer2,upperdir=./rootfs/diff,workdir=./rootfs/work ./rootfs/merged merged:挂载点 diff: upper work: work #问题描述 #当创建一个新的进程并且挂载proc时，退出后在终端执行命令 mount 会出现下面的错误 mount: failed to read mtab: No such file or directory #解决办法 执行下边的命令 就可以在终端执行mount命令了 mount -t proc proc /proc 5.几个常用的关机命令 halt: 关机但不关闭电源（加p参数关闭电源）不加参数时调用shutdown命令 halt -p 相当于poweroff halt -f 强制关机 halt -i 关机或重启前关闭所有网络接口 shutdown实际上是调用init 0, init 0会cleanup一些工作然后调用halt或者poweroff。其实主要区别是halt和poweroff，在没有acpi的系统上，halt只是关闭了os，电源还在工作，你得手动取按一下那个按钮，而poweroff会发送一个关闭电源的信号给acpi。但在现在的系统上，他们实际上都一样了 6.lsblk命令 lsblk可以列出所有可用块设备的信息。比如逻辑磁盘，而df -h 是查看文件系统级别的信息 NAME: 块设备的名称。 MAJ:MIN: 主设备号和次设备号，用于唯一标识设备。 RM: 可移除性标志，0 表示设备不可移除，1 表示设备可移除。 SIZE: 设备的总大小。 RO: 只读标志，0 表示设备可读写，1 表示设备只读。 TYPE: 设备的类型，如 disk 表示硬盘，part 表示分区，rom 表示只读光盘等。 MOUNTPOINT: 如果设备已挂载，显示挂载点；如果未挂载，该字段为空。 7.快捷键 1.ctrl&#43;a #光标回到行首 2.ctrl&#43;e #光标回到行尾 3.ctrl&#43;w #移除光标前的一个单词 4.Ctrl&#43;k #删除光标处到行尾的字符 5.Ctrl&#43;y #粘贴Ctrl&#43;u，Ctrl&#43;k，Ctrl&#43;w删除的文本 6.Esc&#43;b #移动到当前单词的开头 7.Esc&#43;f #移动到当前单词的结尾 8.Ctrl&#43;d #向行尾删除一个字符 8. snat dnat MASQUERADE https://www.cnblogs.com/Dicky-Zhang/p/5934657.html
">
<meta name="twitter:image" content="http://localhost:1313/home/me.png">


<link rel="canonical" href="http://localhost:1313/linux_foundation/linux-common/">


<link rel="stylesheet" href="/css/math.css">


<script>
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      displayMath: [['$$', '$$'], ['\\[', '\\]']],
      processEscapes: true,
      processEnvironments: true
    },
    svg: {
      fontCache: 'global'
    }
  };
</script>
<script id="MathJax-script" async src="/js/mathjax/tex-svg.js"></script> </head>
<body>

<div class="container"><header>
<h1>高新 | AI平台开发工程师</h1><a href="https://github.com/mlcore-engine/mlcore-engine" class="github"><i class="fab fa-github"></i></a>
<p class="description">AI平台开发工程师，专注于AI平台工程和Kubernetes云原生技术。拥有AI平台开发、GPU资源优化和AI服务部署经验</p>

</header>


<div class="content-container">
<main><h1>Linux Common</h1>
<h6 id="0配置阿里yum源">0.配置阿里yum源</h6>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e">#配置阿里yum源命令</span>
</span></span><span style="display:flex;"><span>curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo
</span></span><span style="display:flex;"><span>curl -o /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo
</span></span><span style="display:flex;"><span><span style="color:#75715e">#运行以下命令生成缓存</span>
</span></span><span style="display:flex;"><span>yum clean all
</span></span><span style="display:flex;"><span>yum makecache
</span></span></code></pre></div><h6 id="2查看系统版本">2.查看系统版本</h6>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e">#查看系统发行版本</span>
</span></span><span style="display:flex;"><span>lsb_release -a
</span></span><span style="display:flex;"><span>cat /etc/redhat-release
</span></span><span style="display:flex;"><span><span style="color:#75715e">#查看linux内核版本</span>
</span></span><span style="display:flex;"><span>uname -a
</span></span></code></pre></div><h6 id="3centos中的tmpfs">3.centos中的tmpfs</h6>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e">#是一种临时文件系统，它将一部分系统内存用作虚拟文件系统，用于临时存储数据。tmpfs 的作用是提供一个基于内存的文件系统，可以用来存储临时文件、缓存数据、临时运行时文件等，从而在许多情况下提高性能和效率。</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>/dev/shm  <span style="color:#75715e">#包含共享内存分配</span>
</span></span><span style="display:flex;"><span>/run   <span style="color:#75715e">#用于系统日志</span>
</span></span><span style="display:flex;"><span>/sys/fs/cgroup <span style="color:#75715e">#用于cgroup 一个针对特定进程限制 管理和审计资源利用的内核特性</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#你可以使用systemctl命令在tmp目录启用tmpfs， 首先用下面的命令来检查这个特性是否可用：</span>
</span></span><span style="display:flex;"><span>systemctl is-enabled tmp.mount
</span></span><span style="display:flex;"><span><span style="color:#75715e">#这会显示当先的状态，（如果未启用，）你可以使用下面的命令来启用它：</span>
</span></span><span style="display:flex;"><span>systemctl enable tmp.mount
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#可以在/etc/fstab中添加下面这行，来手工在/tmp下挂载 tmpfs</span>
</span></span><span style="display:flex;"><span>tmpfs /tmp tmpfs size<span style="color:#f92672">=</span>512m <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">0</span>
</span></span></code></pre></div><h6 id="4mount命令用法和问题">4.mount命令用法和问题</h6>
<ul>
<li>mount用法</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>挂载方法： mount Device MOUNT_POINT
</span></span><span style="display:flex;"><span>-t vsftype: 指定要挂载的设备上的文件系统类型 
</span></span><span style="display:flex;"><span>-r readonly : 只读挂载  
</span></span><span style="display:flex;"><span>-w read and write: 读写挂载   
</span></span><span style="display:flex;"><span>-L :以卷标指定挂载设备 
</span></span><span style="display:flex;"><span>-U : 以uuid指定要挂载的设备
</span></span><span style="display:flex;"><span>-B --bind : 绑定目录到另一个目录上
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#卸载命令umount</span>
</span></span><span style="display:flex;"><span>umount DEVICE
</span></span><span style="display:flex;"><span>umount MOUNT_POINT
</span></span><span style="display:flex;"><span><span style="color:#75715e">#重新挂载命令</span>
</span></span><span style="display:flex;"><span>mount -o remount /dev/shm
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#当加入一块新设备时 1.要对设备进行格式化（制作文件系统） 2. 将其挂载到指定目录</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#格式化</span>
</span></span><span style="display:flex;"><span>mkfs -t ext4 /dev/sdb
</span></span><span style="display:flex;"><span><span style="color:#75715e">#挂载</span>
</span></span><span style="display:flex;"><span>mount /dev/sdb /xxx/
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#进阶版</span>
</span></span><span style="display:flex;"><span>$ mount
</span></span><span style="display:flex;"><span>sysfs on /sys type sysfs <span style="color:#f92672">(</span>rw,nosuid,nodev,noexec,relatime,seclabel<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#输出信息的格式和含义</span>
</span></span><span style="display:flex;"><span>fs_spec on fs_file type fs_vfstype <span style="color:#f92672">(</span>fs_mntopts<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>fs_spec:挂载的块设备或者远程文件系统
</span></span><span style="display:flex;"><span>fs_file:文件系统的挂载点
</span></span><span style="display:flex;"><span>fs_vfstype:文件系统的类型
</span></span><span style="display:flex;"><span>fs_mntopts:与文件系统的相关选项
</span></span><span style="display:flex;"><span>第一行的含义:挂载的设备是sysfs 挂载点是/sys 文件系统的类型是sysfs 括号中rw代表可读写的方式挂载文件系统 noexec表示不能再该文件系统上直接运行程序
</span></span></code></pre></div><ul>
<li>overlay</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>mkdir layer1 layer2
</span></span><span style="display:flex;"><span>mkdir ./rootfs/<span style="color:#f92672">{</span>merged,diff,work<span style="color:#f92672">}</span> -p
</span></span><span style="display:flex;"><span>mount -t overlay overlay -o lowerdir<span style="color:#f92672">=</span>./layer1:./layer2,upperdir<span style="color:#f92672">=</span>./rootfs/diff,workdir<span style="color:#f92672">=</span>./rootfs/work ./rootfs/merged
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>merged:挂载点
</span></span><span style="display:flex;"><span>diff: upper
</span></span><span style="display:flex;"><span>work: work
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e">#问题描述</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#当创建一个新的进程并且挂载proc时，退出后在终端执行命令 mount 会出现下面的错误</span>
</span></span><span style="display:flex;"><span>mount: failed to read mtab: No such file or directory
</span></span><span style="display:flex;"><span><span style="color:#75715e">#解决办法 执行下边的命令 就可以在终端执行mount命令了</span>
</span></span><span style="display:flex;"><span>mount -t proc proc /proc
</span></span></code></pre></div><h6 id="5几个常用的关机命令">5.几个常用的关机命令</h6>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>halt: 关机但不关闭电源（加p参数关闭电源）不加参数时调用shutdown命令
</span></span><span style="display:flex;"><span>halt -p 相当于poweroff
</span></span><span style="display:flex;"><span>halt -f 强制关机
</span></span><span style="display:flex;"><span>halt -i 关机或重启前关闭所有网络接口
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>shutdown实际上是调用init 0, init 0会cleanup一些工作然后调用halt或者poweroff。其实主要区别是halt和poweroff，在没有acpi的系统上，halt只是关闭了os，电源还在工作，你得手动取按一下那个按钮，而poweroff会发送一个关闭电源的信号给acpi。但在现在的系统上，他们实际上都一样了
</span></span></code></pre></div><h6 id="6lsblk命令">6.lsblk命令</h6>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>lsblk可以列出所有可用块设备的信息。比如逻辑磁盘，而df -h 是查看文件系统级别的信息
</span></span><span style="display:flex;"><span>NAME: 块设备的名称。
</span></span><span style="display:flex;"><span>MAJ:MIN: 主设备号和次设备号，用于唯一标识设备。
</span></span><span style="display:flex;"><span>RM: 可移除性标志，0 表示设备不可移除，1 表示设备可移除。
</span></span><span style="display:flex;"><span>SIZE: 设备的总大小。
</span></span><span style="display:flex;"><span>RO: 只读标志，0 表示设备可读写，1 表示设备只读。
</span></span><span style="display:flex;"><span>TYPE: 设备的类型，如 disk 表示硬盘，part 表示分区，rom 表示只读光盘等。
</span></span><span style="display:flex;"><span>MOUNTPOINT: 如果设备已挂载，显示挂载点；如果未挂载，该字段为空。
</span></span></code></pre></div><h6 id="7快捷键">7.快捷键</h6>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>1.ctrl+a <span style="color:#75715e">#光标回到行首</span>
</span></span><span style="display:flex;"><span>2.ctrl+e <span style="color:#75715e">#光标回到行尾</span>
</span></span><span style="display:flex;"><span>3.ctrl+w <span style="color:#75715e">#移除光标前的一个单词</span>
</span></span><span style="display:flex;"><span>4.Ctrl+k <span style="color:#75715e">#删除光标处到行尾的字符</span>
</span></span><span style="display:flex;"><span>5.Ctrl+y <span style="color:#75715e">#粘贴Ctrl+u，Ctrl+k，Ctrl+w删除的文本</span>
</span></span><span style="display:flex;"><span>6.Esc+b <span style="color:#75715e">#移动到当前单词的开头</span>
</span></span><span style="display:flex;"><span>7.Esc+f <span style="color:#75715e">#移动到当前单词的结尾</span>
</span></span><span style="display:flex;"><span>8.Ctrl+d <span style="color:#75715e">#向行尾删除一个字符</span>
</span></span></code></pre></div><h6 id="8-snat-dnat-masquerade">8. snat dnat MASQUERADE</h6>
<p><a href="https://www.cnblogs.com/Dicky-Zhang/p/5934657.html">https://www.cnblogs.com/Dicky-Zhang/p/5934657.html</a></p>
<h3 id="9进程信息区统计信息区域各列含义">9.进程信息区统计信息区域各列含义</h3>
<ol>
<li>PID &mdash;进程id</li>
<li>PPID &mdash;父进程id</li>
<li>RUSER &mdash; REAL USER NAME</li>
<li>UID &mdash; 进程所有者的用户id</li>
<li>USER &mdash;进程所有者的用户名</li>
<li>GROUP &mdash;进程所有者的组名</li>
<li>TTY &mdash; 启动进程的终端名。不是从终端启动的进程则显示为 ?</li>
<li>NI &mdash; nice值。负值表示高优先级，正值表示低优先级</li>
<li>P &mdash; 最后使用的CPU，仅在多CPU环境下有意义</li>
<li>%CPU &mdash;  上次更新到现在的CPU时间占用百分比</li>
<li>%MEM &mdash; 进程使用的物理内存百分比</li>
<li>TIME &mdash; 进程使用的CPU时间总计，单位秒</li>
<li>VIRT &mdash; 进程使用的虚拟内存总量 单位kb。VIRT=SWAP+RES</li>
</ol>
<h3 id="10stress-工具">10.stress 工具</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>-v 显示版本号
</span></span><span style="display:flex;"><span>-q 不显示运行信息
</span></span><span style="display:flex;"><span>-n 显示已完成的指令情况
</span></span><span style="display:flex;"><span>-t --timeout N 指定运行N秒后结束 
</span></span><span style="display:flex;"><span>--backup N 指定N微秒后运行 
</span></span><span style="display:flex;"><span>-c 产生n个进程 每个进程都反复不停的计算随机数的平方根
</span></span><span style="display:flex;"><span>-i 产生n个进程 每个进程反复调用sync<span style="color:#f92672">()</span>，sync<span style="color:#f92672">()</span>用于将内存上的内容写到硬盘上
</span></span><span style="display:flex;"><span>-m --vm n 产生n个进程,每个进程不断调用内存分配malloc和内存释放free函数
</span></span><span style="display:flex;"><span>--vm-bytes B 指定malloc时内存的字节数 （默认256MB）
</span></span><span style="display:flex;"><span>--vm-hang N 指定在free前的秒数
</span></span><span style="display:flex;"><span>-d --hadd n 产生n个执行write和unlink函数的进程
</span></span><span style="display:flex;"><span>-hadd-bytes B 指定写的字节数
</span></span><span style="display:flex;"><span>--hadd-noclean 不unlink
</span></span><span style="display:flex;"><span>--vm-hang 表示malloc分配的内存多少时间后在free<span style="color:#f92672">()</span>释放掉
</span></span><span style="display:flex;"><span>时间单位可以为秒s，分m，小时h，天d，年y，文件大小单位可以为K，M，G
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>-d forks
</span></span><span style="display:flex;"><span>--hdd forks 产生多个执行write<span style="color:#f92672">()</span>函数的进程
</span></span><span style="display:flex;"><span>--hdd-bytes bytes 指定写的Bytes数，默认是1GB
</span></span><span style="display:flex;"><span>--hdd-noclean 不要将写入随机ASCII数据的文件Unlink
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">v1</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Pod</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">metadata</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">memory-demo</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">namespace</span>: <span style="color:#ae81ff">mem-example</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">spec</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">containers</span>:
</span></span><span style="display:flex;"><span>  - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">memory-demo-ctr</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">image</span>: <span style="color:#ae81ff">polinux/stress</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">resources</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">limits</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">memory</span>: <span style="color:#e6db74">&#34;200Mi&#34;</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">requests</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">memory</span>: <span style="color:#e6db74">&#34;100Mi&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">command</span>: [<span style="color:#e6db74">&#34;stress&#34;</span>]
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">args</span>: [<span style="color:#e6db74">&#34;--vm&#34;</span>, <span style="color:#e6db74">&#34;1&#34;</span>, <span style="color:#e6db74">&#34;--vm-bytes&#34;</span>, <span style="color:#e6db74">&#34;150M&#34;</span>, <span style="color:#e6db74">&#34;--vm-hang&#34;</span>, <span style="color:#e6db74">&#34;1&#34;</span>]
</span></span></code></pre></div><h3 id="11端口查询">11.端口查询</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e">#netstat</span>
</span></span><span style="display:flex;"><span>-t 指明tcp -u 指明udp -l 仅显示监听套接字 -p 显示进程标识符和程序名称 -n 不进行DNS轮询，显示ip
</span></span><span style="display:flex;"><span>netstat -ntlp 查看所有tcp端口
</span></span><span style="display:flex;"><span>netstat -tunlp | grep <span style="color:#ae81ff">80</span> <span style="color:#75715e">#查看所有80端口使用情况</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#lsof</span>
</span></span><span style="display:flex;"><span>lsof -i:80 <span style="color:#75715e">#查看80占用</span>
</span></span><span style="display:flex;"><span>lsof ab.txt <span style="color:#75715e">#显示开启文件ab.txt的进程</span>
</span></span><span style="display:flex;"><span>lsof -c -p <span style="color:#ae81ff">1234</span> <span style="color:#75715e">#列出进程号为1234的进程所有打开的文件</span>
</span></span><span style="display:flex;"><span>lsof +d /usr/local <span style="color:#75715e">#显示目录下被进程开启的文件</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#一般使用方法</span>
</span></span><span style="display:flex;"><span>$netstat -tunlp | grep <span style="color:#ae81ff">80</span>
</span></span><span style="display:flex;"><span>tcp        <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span> 0.0.0.0:80              0.0.0.0:*               LISTEN      27314/nginx: master 
</span></span><span style="display:flex;"><span>tcp6       <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span> :::80                   :::*                    LISTEN      27314/nginx: master 
</span></span><span style="display:flex;"><span>udp        <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span> 0.0.0.0:68              0.0.0.0:*                           2808/dhclient       
</span></span><span style="display:flex;"><span>udp6       <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span> fe80::5054:ff:fe02::123 :::*                                2501/ntpd 
</span></span><span style="display:flex;"><span>$ps -aux | grep <span style="color:#ae81ff">27314</span>
</span></span><span style="display:flex;"><span>root     <span style="color:#ae81ff">27314</span>  0.0  0.1 <span style="color:#ae81ff">125108</span>  <span style="color:#ae81ff">2116</span> ?        Ss   08:58   0:00 nginx: master process /usr/sbin/nginx
</span></span><span style="display:flex;"><span>root     <span style="color:#ae81ff">28492</span>  0.0  0.0 <span style="color:#ae81ff">112708</span>   <span style="color:#ae81ff">980</span> pts/0    R+   09:17   0:00 grep --color<span style="color:#f92672">=</span>auto <span style="color:#ae81ff">27314</span>
</span></span></code></pre></div><h3 id="12内网安装mariadb">12.内网安装Mariadb</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ yum install mariadb-server mariadb
</span></span><span style="display:flex;"><span>$ systemctl start mariadb
</span></span><span style="display:flex;"><span>$ systemctl enable mariadb
</span></span><span style="display:flex;"><span><span style="color:#75715e">#修改密码</span>
</span></span><span style="display:flex;"><span>$ mysql
</span></span><span style="display:flex;"><span>$ use mysql;
</span></span><span style="display:flex;"><span>$ update user set password<span style="color:#f92672">=</span>password<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Gree!2018&#34;</span><span style="color:#f92672">)</span> where user <span style="color:#f92672">=</span><span style="color:#e6db74">&#39;root&#39;</span>;
</span></span><span style="display:flex;"><span>$ flush privileges;
</span></span><span style="display:flex;"><span><span style="color:#75715e">#设置白名单</span>
</span></span><span style="display:flex;"><span>$ grant all privileges on *.* to <span style="color:#e6db74">&#39;username&#39;</span>@<span style="color:#e6db74">&#39;host&#39;</span> identified by <span style="color:#e6db74">&#39;Gree!2018&#39;</span> with grant option;
</span></span><span style="display:flex;"><span>$ flush privileges;
</span></span></code></pre></div><h3 id="13安装mysql">13.安装mysql</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ wget http://dev.mysql.com/get/mysql57-community-release-el7-8.noarch.rpm
</span></span><span style="display:flex;"><span>$ yum localinstall mysql57-community-release-el7-8.noarch.rpm
</span></span><span style="display:flex;"><span>$ yum repolist enabled | grep <span style="color:#e6db74">&#34;mysql.*-community.*&#34;</span>
</span></span><span style="display:flex;"><span>$ yum install mysql-community-server
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 找到初始密码</span>
</span></span><span style="display:flex;"><span>$ vi /var/log/mysqld.log
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#查找密码位置</span>
</span></span><span style="display:flex;"><span>$ /temporary password
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#当找不到密码时，编辑这个文件 </span>
</span></span><span style="display:flex;"><span>$ vi /etc/my.cnf 
</span></span><span style="display:flex;"><span><span style="color:#75715e">#添加一行代码，然后重启mysql 然后输入mysql直接进入  </span>
</span></span><span style="display:flex;"><span>skip-grant-tables 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#设置密码</span>
</span></span><span style="display:flex;"><span>$ set password <span style="color:#66d9ef">for</span> <span style="color:#e6db74">&#39;root&#39;</span>@<span style="color:#e6db74">&#39;localhost&#39;</span><span style="color:#f92672">=</span>password<span style="color:#f92672">(</span><span style="color:#e6db74">&#39;password!&#39;</span><span style="color:#f92672">)</span>; 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 允许远程连接 </span>
</span></span><span style="display:flex;"><span>$ grant all on *.* to root@<span style="color:#e6db74">&#39;%&#39;</span> identified by <span style="color:#e6db74">&#39;password&#39;</span> with grant option;  
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 如果需要设置简单密码 </span>
</span></span><span style="display:flex;"><span>$ set global validate_password_policy<span style="color:#f92672">=</span>0; 
</span></span><span style="display:flex;"><span>$ set global validate_password_length<span style="color:#f92672">=</span>1; 
</span></span><span style="display:flex;"><span>$ set global validate_password_mixed_case_count<span style="color:#f92672">=</span>2;  
</span></span><span style="display:flex;"><span><span style="color:#75715e">#增加白名单</span>
</span></span><span style="display:flex;"><span>mysql&gt; use mysql 
</span></span><span style="display:flex;"><span>mysql&gt; GRANT ALL ON *.* to root@<span style="color:#e6db74">&#39;172.28.171.176&#39;</span> IDENTIFIED BY <span style="color:#e6db74">&#39;your-root-password&#39;</span>;   
</span></span><span style="display:flex;"><span>mysql&gt; FLUSH PRIVILEGES;  
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e">#完全卸载mysql </span>
</span></span><span style="display:flex;"><span>$ yum remove mysql 
</span></span><span style="display:flex;"><span>$ find / -name mysql 
</span></span><span style="display:flex;"><span>rm -rf /usr/lib64/mysql 
</span></span><span style="display:flex;"><span>rm -rf /usr/share/mysql 
</span></span><span style="display:flex;"><span>rm -rf /usr/bin/mysql
</span></span><span style="display:flex;"><span>rm -rf /etc/logrotate.d/mysql
</span></span><span style="display:flex;"><span>rm -rf /var/lib/mysql
</span></span><span style="display:flex;"><span>rm -rf /var/lib/mysql/mysql
</span></span><span style="display:flex;"><span>rm –rf /usr/my.cnf
</span></span><span style="display:flex;"><span>rm -rf /root/.mysql_sercret  
</span></span><span style="display:flex;"><span>rm -rf /var/logs/mysql
</span></span></code></pre></div><h3 id="14df-du-free">14.df du free</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>du -h: 显示每个文件和目录的磁盘使用空间~~~文件的大小 
</span></span><span style="display:flex;"><span>du -h --max-depth <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>df -h：显示磁盘分区上可以使用的磁盘空间 <span style="color:#75715e">#-a    #查看全部文件系统，单位默认KB   -h  使用-h选项以KB、MB、GB的单位来显示，可读性高~~~（最常用）</span>
</span></span><span style="display:flex;"><span>df -T：查看磁盘格式
</span></span><span style="display:flex;"><span>free -h：可以显示Linux系统中空闲的、已用的物理内存及swap内存,及被内核使用的buffer
</span></span></code></pre></div><p>###15.ipvs iptables</p>
<ol>
<li>三种工作模式</li>
</ol>
<ul>
<li>nat</li>
<li>tun</li>
<li>dr</li>
</ul>
<h3 id="16添加环境变量">16.添加环境变量</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ vi /etc/profile
</span></span><span style="display:flex;"><span>unset i
</span></span><span style="display:flex;"><span>unset -f pathmunge
</span></span><span style="display:flex;"><span><span style="color:#75715e">#添加环境变量</span>
</span></span><span style="display:flex;"><span>PATH<span style="color:#f92672">=</span>$PATH:/usr/local/go/bin
</span></span><span style="display:flex;"><span>export PATH
</span></span><span style="display:flex;"><span>$ source /etc/profile
</span></span></code></pre></div><p>###17.centos7 安装 OpenSSL</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ wget http://www.openssl.org/source/openssl-1.0.2f.tar.gz
</span></span><span style="display:flex;"><span>$ tar -zxvf tar -xzf openssl-1.0.2f.tar.gz
</span></span><span style="display:flex;"><span>$ cd openssl-1.0.2f
</span></span><span style="display:flex;"><span>$ mkdir /usr/local/openssl
</span></span><span style="display:flex;"><span>$ ./config --prefix<span style="color:#f92672">=</span>/usr/local/openssl
</span></span><span style="display:flex;"><span>$ make
</span></span><span style="display:flex;"><span>$ make install
</span></span><span style="display:flex;"><span>$ ln -s /usr/local/openssl/bin/openssl /usr/bin/openssl
</span></span><span style="display:flex;"><span>$ cd /usr/local/openssl
</span></span><span style="display:flex;"><span>$ ldd /usr/local/openssl/bin/openssl
</span></span><span style="display:flex;"><span>$ vim /etc/ld.so.conf
</span></span><span style="display:flex;"><span><span style="color:#75715e">#在最后追加一行</span>
</span></span><span style="display:flex;"><span>/usr/local/openssl/lib 
</span></span><span style="display:flex;"><span>$ ldconfig /etc/ld.so.conf
</span></span><span style="display:flex;"><span>$ openssl version
</span></span></code></pre></div><p>###18.删除网桥</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ yum install bridge-utils
</span></span><span style="display:flex;"><span><span style="color:#75715e">#添加网桥</span>
</span></span><span style="display:flex;"><span>$ brctl addbr br0
</span></span><span style="display:flex;"><span><span style="color:#75715e">#设置br0</span>
</span></span><span style="display:flex;"><span>$ ifconfig br0 192.168.1.100.1 netmask 255.255.255.0
</span></span><span style="display:flex;"><span><span style="color:#75715e">#查看网桥</span>
</span></span><span style="display:flex;"><span>$ brctl show
</span></span><span style="display:flex;"><span><span style="color:#75715e">#删除网桥</span>
</span></span><span style="display:flex;"><span>$ brctl delbr br0
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 将eth0端口加入网桥br0</span>
</span></span><span style="display:flex;"><span>$ brctl addif br0 eth0
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 从网桥br0中删除eth0端口</span>
</span></span><span style="display:flex;"><span>$ brctl delif br0 eth0
</span></span></code></pre></div><h3 id="19安装jdk和maven">19.安装jdk和maven</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ mkdir /usr/local/java/
</span></span><span style="display:flex;"><span>$ tar -zxvf jdk-8u171-linux-x64.tar.gz -C /usr/local/java/
</span></span><span style="display:flex;"><span>$ mv /usr/local/java/jdk1.8.0_191 /usr/local/java/jdk
</span></span><span style="display:flex;"><span>$ vi /etc/profile
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>export JAVA_HOME<span style="color:#f92672">=</span>/usr/local/java/jdk
</span></span><span style="display:flex;"><span>export JRE_HOME<span style="color:#f92672">=</span><span style="color:#e6db74">${</span>JAVA_HOME<span style="color:#e6db74">}</span>/jre
</span></span><span style="display:flex;"><span>export CLASSPATH<span style="color:#f92672">=</span>.:<span style="color:#e6db74">${</span>JAVA_HOME<span style="color:#e6db74">}</span>/lib:<span style="color:#e6db74">${</span>JRE_HOME<span style="color:#e6db74">}</span>/lib
</span></span><span style="display:flex;"><span>export PATH<span style="color:#f92672">=</span><span style="color:#e6db74">${</span>JAVA_HOME<span style="color:#e6db74">}</span>/bin:$PATH
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ source /etc/profile
</span></span><span style="display:flex;"><span><span style="color:#75715e">#建立一个软连接</span>
</span></span><span style="display:flex;"><span>$ ln -s /usr/local/java/jdk/bin/java /usr/bin/java
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#修改链接</span>
</span></span><span style="display:flex;"><span>$ ln -snf <span style="color:#f92672">[</span>新目标地址<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>软连接地址<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#删除</span>
</span></span><span style="display:flex;"><span>$ rm -rf <span style="color:#f92672">[</span>软连接地址<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#安装maven</span>
</span></span><span style="display:flex;"><span>$ tar -zxf apache-maven-3.3.9-bin.tar.gz
</span></span><span style="display:flex;"><span>$ unzip apache-maven-3.5.4-bin.zip
</span></span><span style="display:flex;"><span>$ mv apache-maven-3.3.9 /usr/local/maven/
</span></span><span style="display:flex;"><span>$ vi /etc/profile
</span></span><span style="display:flex;"><span>M2_HOME<span style="color:#f92672">=</span>/usr/local/maven/apache-maven-3.3.9
</span></span><span style="display:flex;"><span>export PATH<span style="color:#f92672">=</span><span style="color:#e6db74">${</span>M2_HOME<span style="color:#e6db74">}</span>/bin:<span style="color:#e6db74">${</span>PATH<span style="color:#e6db74">}</span>
</span></span><span style="display:flex;"><span>$ source /etc/profile
</span></span></code></pre></div><h3 id="20shell中正则表达">20.shell中正则表达</h3>
<p>正则表达式是对文本进行过滤的工具，之所以有过滤文本的功能，因为它定义了一系列元字符，通过元字符配合其他字符来表达出一种规则。只有符合该规则上午文本才能保留下来</p>
<p>元字符： 描述字符的字符</p>
<p>元字符作用： 对表达式的内容转换以及各种操作信息进行描述</p>
<ul>
<li>基础表达式</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e">#基础表达式仅支持最基本的元字符集</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#基础正则表达式的元字符主要有：</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#1. 行首定位符 &#34;^&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#用来匹配行首的字符。表示行首的字符是 ^ 后面的那个字符 行首定位符位于所作用的字符之前</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 例 列出 /etc 目录中以字母po开头的文件名</span>
</span></span><span style="display:flex;"><span>$ str <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;ls /etc | grep &#34;^po&#34;&#39;</span>
</span></span><span style="display:flex;"><span>$ echo <span style="color:#e6db74">&#34;</span>$str<span style="color:#e6db74">&#34;</span> 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#2. 行尾定位符 &#34;$&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#作用： 定位文本行的末尾 行尾定位符位于所作用的字符之后</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#例 列出 /etc 目录中以conf结尾的文件名</span>
</span></span><span style="display:flex;"><span>$ ls /etc | grep <span style="color:#e6db74">&#39;conf$&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#注意： ^cat$ 完全匹配cat的文本行 单独的 ^ 和 $ 没有任何意义，因为任何一个文本行都有开头和结尾。</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#3. 单个字符匹配 &#34;.&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># . 用来匹配任何单个字符。 包括空格 但不包括换行符\n。 当使用 &#34;.&#34; 意味着该位置一定有一个字符 无论他是什么字符</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 例 列出所有的包含字符串 &#34;samba&#34; 的文件名， 不管samba后面有没有字符</span>
</span></span><span style="display:flex;"><span>$ ls /etc | grep <span style="color:#e6db74">&#39;samba&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 列出包含字符串samba 且samba后面只是含有一个字符</span>
</span></span><span style="display:flex;"><span>$ ls /etc | grep <span style="color:#e6db74">&#39;samba.&#39;</span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e">#可以连续使用..来匹配多个字符，如l..p，匹配含义字母l,然后是两个任意字符，再接着是字母p的字符串</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#4. 限定符 &#34;*&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#限定符本身不代表任何字符，用来指定其前面的一个字符必须重复出现多次才能满足匹配。而星号表示匹配其前导字符的任意次数 包括0次</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#例 筛选出以字符s开头 紧跟着1个字符s 再接着任意个字符s的文件名</span>
</span></span><span style="display:flex;"><span>$ ls /etc | grep <span style="color:#e6db74">&#39;^sss*&#39;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#5. 字符集匹配 &#34;[]&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#只要某个字符串在方括号所在的位置上出现了方括号中的任意一个字符 就满足匹配条件。 对于连续的数字和字母 可使用 - 来表示一个范围   如： [a-z]表示匹配a到z中的任意一个字符 [0-9]匹配0-9任意一个数字</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#6. [^] 字符集不匹配</span>
</span></span></code></pre></div><ul>
<li>扩展正则表达</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e">#egerep命令默认使用扩展正则表达式</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#1. 限定符 &#34;+&#34;  </span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#限定符+ 用于限定前面的字符至少出现一次</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#例 筛选以字符串 &#34;s&#34; 开头， 后面至少紧跟着1个字符 &#34;s&#34; 的文本行</span>
</span></span><span style="display:flex;"><span>$ ls /etc | egrep <span style="color:#e6db74">&#39;^ss+&#39;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#2. 限定符 &#34;?&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#限定前面的字符最多只出现一次</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#例 筛选以字符串 &#34;s&#34;开头 后面跟着0个或者1个s的文本行</span>
</span></span><span style="display:flex;"><span>$ ls /etc | egrep <span style="color:#e6db74">&#39;^ss?&#39;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#3. 竖线 &#34;|&#34; 和圆括号 &#34;()&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#竖线|表达多个正则表达式之间的关系 括号表示一组可选的集合 竖线和圆括号经常一起使用 表示一组可选值</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#例 筛选含有字符串 &#34;ssh&#34; 或 &#34;ssl&#34; 或者 以字符串 &#34;yum&#34; 开头的文本行</span>
</span></span><span style="display:flex;"><span>$ ls /etc | egrep <span style="color:#e6db74">&#39;(ssh|ssl|^yum)&#39;</span>
</span></span></code></pre></div><ul>
<li>perl正则表达式</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>1.数组匹配 <span style="color:#ae81ff">\d</span>
</span></span><span style="display:flex;"><span>2.非数字匹配 <span style="color:#ae81ff">\D</span>
</span></span><span style="display:flex;"><span>3.空白字符匹配 <span style="color:#ae81ff">\s</span>
</span></span><span style="display:flex;"><span>4.非空白字符匹配 <span style="color:#ae81ff">\S</span>
</span></span></code></pre></div><ul>
<li>应用</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e">#1.单个一般字符 </span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#搜索文本中含有 &#34;a&#34; 的文本行</span>
</span></span><span style="display:flex;"><span>$ grep <span style="color:#e6db74">&#39;a&#39;</span> demo.txt
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#2.转义后的元字符</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#要匹配元字符本身 需要在这些字符前面加 \ 关闭这些元字符的特殊意义 保留其字面意义 反斜线也是元字符 如果匹配 要 &#39;\\&#39;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#3.方括号表达式</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#当元字符位于方括号中时， 除了连字符 - 或者 ^ 之外 其他元字符都会失去特殊意义 [\.] 表示的是反斜线\和原点.这两个字符 如果匹配原点 [.] 就够了</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#4. 方括号或星号等配合</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#匹配任意多个字符 &#34;o&#34;</span>
</span></span><span style="display:flex;"><span>$ egrep <span style="color:#e6db74">&#39;lo*king&#39;</span> demo.txt
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#优先级</span>
</span></span><span style="display:flex;"><span>1. <span style="color:#ae81ff">\ </span>转义符
</span></span><span style="display:flex;"><span>2. <span style="color:#f92672">[]</span> 方括号表达式
</span></span><span style="display:flex;"><span>3. <span style="color:#f92672">()</span> 分组
</span></span><span style="display:flex;"><span>4.  *.+?<span style="color:#f92672">{</span>m<span style="color:#f92672">}</span> 限定符
</span></span><span style="display:flex;"><span>5. 普通字符 从左到右
</span></span><span style="display:flex;"><span>6. ^ $ 定位符
</span></span><span style="display:flex;"><span>7. | 或运算
</span></span><span style="display:flex;"><span>（从高到低）
</span></span></code></pre></div><h3 id="21linux-网络管理命令">21.linux 网络管理命令</h3>
<ul>
<li>linux中主要三类网络管理命令：1. ifconfig route netstat 属于传统功能单一 网络命令 2. ip ss 属于综合类网络命令 3. nmcli适用于RHEL7的综合网络命令</li>
</ul>
<ol>
<li>ifconfig</li>
</ol>
<p>格式： ifconfig [interface] [up | down]</p>
<p>常用选项： -a 显示所有网络接口信息 -s 显示网络接口统计信息</p>
<p>ifconfig INT address 配置指定网络接口的IP 地址</p>
<p>ifconfig INT IP/MASK 修改指定设备的ip地址</p>
<p>例： ifconfig eth0 192.168.1.166 255.255.255.0</p>
<ol start="2">
<li>route</li>
</ol>
<p>格式:  route 查看路由条目</p>
<p>-n 对域名不进行解析 以IP地址进行显示</p>
<ol start="3">
<li>IP命令</li>
</ol>
<p>格式： ip [options] object { command | help }</p>
<p>object 为 link 时 用于配置本机的二层链路属性配置    对应command为：</p>
<p>ip link set DEVICE {up | down | arp {on | off }}</p>
<p>例： ip link set eth0 down     ip link show</p>
<p>object为address时 用于设置本机ip</p>
<p>ip addr { add | del } IFADDR dev STRING: 对指定网络接口添加或删除IP地址</p>
<p>ip addr { show | flush } [ dev STRING ]: 查看或清空指定设备的IP地址</p>
<p>add IP/MASK: 为设备添加地址</p>
<p>delete IP: 删除设备配置的地址</p>
<p>flush: 清空指定设备中的配置</p>
<p>show: 查看IP地址配置</p>
<p>通过add命令添加指定IP地址</p>
<p>ip addr 192.168.1.88/24 dev eth0    &amp;&amp; ip addr show dev eth0</p>
<p>object 为 route 时 用于设置本机路由条目</p>
<p>ip route { list | flush } SELECTOR: 查看或清空路由条目</p>
<p>ip route { add | del | change | append | replace | monitor } ROUTE: 修改路由条目</p>
<p>add 添加路由条目</p>
<p>ip route add 0/0 via 10.10.10.252</p>
<p>change修改路由条目</p>
<p>ip route change 0/0 via 192.168.1.2 dev eth0</p>
<p>（ip route ip rule iptables 关系）https://www.cnblogs.com/EasonJim/p/8424731.html</p>
<h3 id="22制作文件系统">22.制作文件系统</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e">#添加过程不做描述</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#1.添加之后重启虚拟机 </span>
</span></span><span style="display:flex;"><span>$ shutdown -r now
</span></span><span style="display:flex;"><span><span style="color:#75715e">#2.使用fdisk -l 命令查看当前系统的分区</span>
</span></span><span style="display:flex;"><span>Disk /dev/sda: 21.5 GB, <span style="color:#ae81ff">21474836480</span> bytes, <span style="color:#ae81ff">41943040</span> sectors
</span></span><span style="display:flex;"><span>Units <span style="color:#f92672">=</span> sectors of <span style="color:#ae81ff">1</span> * 512 <span style="color:#f92672">=</span> <span style="color:#ae81ff">512</span> bytes
</span></span><span style="display:flex;"><span>Sector size <span style="color:#f92672">(</span>logical/physical<span style="color:#f92672">)</span>: <span style="color:#ae81ff">512</span> bytes / <span style="color:#ae81ff">512</span> bytes
</span></span><span style="display:flex;"><span>I/O size <span style="color:#f92672">(</span>minimum/optimal<span style="color:#f92672">)</span>: <span style="color:#ae81ff">512</span> bytes / <span style="color:#ae81ff">512</span> bytes
</span></span><span style="display:flex;"><span>Disk label type: dos
</span></span><span style="display:flex;"><span>Disk identifier: 0x00007915
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>   Device Boot      Start         End      Blocks   Id  System
</span></span><span style="display:flex;"><span>/dev/sda1   *        <span style="color:#ae81ff">2048</span>     <span style="color:#ae81ff">2099199</span>     <span style="color:#ae81ff">1048576</span>   <span style="color:#ae81ff">83</span>  Linux
</span></span><span style="display:flex;"><span>/dev/sda2         <span style="color:#ae81ff">2099200</span>    <span style="color:#ae81ff">41943039</span>    <span style="color:#ae81ff">19921920</span>   8e  Linux LVM
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Disk /dev/sdb: 21.5 GB, <span style="color:#ae81ff">21474836480</span> bytes, <span style="color:#ae81ff">41943040</span> sectors
</span></span><span style="display:flex;"><span>Units <span style="color:#f92672">=</span> sectors of <span style="color:#ae81ff">1</span> * 512 <span style="color:#f92672">=</span> <span style="color:#ae81ff">512</span> bytes
</span></span><span style="display:flex;"><span>Sector size <span style="color:#f92672">(</span>logical/physical<span style="color:#f92672">)</span>: <span style="color:#ae81ff">512</span> bytes / <span style="color:#ae81ff">512</span> bytes
</span></span><span style="display:flex;"><span>I/O size <span style="color:#f92672">(</span>minimum/optimal<span style="color:#f92672">)</span>: <span style="color:#ae81ff">512</span> bytes / <span style="color:#ae81ff">512</span> bytes
</span></span><span style="display:flex;"><span>Disk label type: dos
</span></span><span style="display:flex;"><span>Disk identifier: 0xc223a63b
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#3.显示sdb未分区 对新建的磁盘进行分区</span>
</span></span><span style="display:flex;"><span>$ fdisk /dev/sdb
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Command <span style="color:#f92672">(</span>m <span style="color:#66d9ef">for</span> help<span style="color:#f92672">)</span>: 
</span></span><span style="display:flex;"><span>Command action
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#输入m 则会出现提示</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#再输入n （add a new partition）添加一个新分区</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#依次输入p 和 1 接着便是提示卷的起始地址和结束地址 都保持默认按回车（意思是只有一个分区）</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#输入w保存退出</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#再次使用fdisk -l 这个命令来查看会发现出现了 /dev/sdb1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#4.进行格式化操作 格式化成xfs文件系统</span>
</span></span><span style="display:flex;"><span>$ mkfs -t xfs /dev/sdb1
</span></span><span style="display:flex;"><span><span style="color:#75715e">#5.对分区好的磁盘进行挂载</span>
</span></span><span style="display:flex;"><span>$ mount /dev/sdb1 /dataall
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#常用小命令</span>
</span></span><span style="display:flex;"><span>$ df -lhT <span style="color:#75715e"># 查看文件系统格式 mount 也可以 或者 file -s /dev/sda1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#使用parted分区</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 使用 lsblk,fdisk,df 等命令查看当前分区信息 </span>
</span></span><span style="display:flex;"><span>lsblk
</span></span><span style="display:flex;"><span>fdisk -l
</span></span><span style="display:flex;"><span>df -TH
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 使用 /dev/sdb1 为例</span>
</span></span><span style="display:flex;"><span>parted /dev/sdb1
</span></span><span style="display:flex;"><span>parted <span style="color:#f92672">(</span>GNU parted<span style="color:#f92672">)</span> 3.1
</span></span><span style="display:flex;"><span>Welcome to GNU Parted! Type <span style="color:#e6db74">&#39;help&#39;</span> to view a list of commands.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 使用 help 查看帮助</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>parted<span style="color:#f92672">)</span> help
</span></span><span style="display:flex;"><span>  check NUMBER                             <span style="color:#66d9ef">do</span> a simple check on the file system
</span></span><span style="display:flex;"><span>  cp <span style="color:#f92672">[</span>FROM-DEVICE<span style="color:#f92672">]</span> FROM-NUMBER TO-NUMBER   copy file system to another partition
</span></span><span style="display:flex;"><span>  help <span style="color:#f92672">[</span>COMMAND<span style="color:#f92672">]</span>                           prints general help, or help on COMMAND
</span></span><span style="display:flex;"><span>  mklabel,mktable LABEL-TYPE               create a new disklabel <span style="color:#f92672">(</span>partition table<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>  mkfs NUMBER FS-TYPE                      make a FS-TYPE file system on partititon NUMBER
</span></span><span style="display:flex;"><span>  mkpart PART-TYPE <span style="color:#f92672">[</span>FS-TYPE<span style="color:#f92672">]</span> START END     make a partition
</span></span><span style="display:flex;"><span>  mkpartfs PART-TYPE FS-TYPE START END     make a partition with a file system
</span></span><span style="display:flex;"><span>  move NUMBER START END                    move partition NUMBER
</span></span><span style="display:flex;"><span>  name NUMBER NAME                         name partition NUMBER as NAME
</span></span><span style="display:flex;"><span>  print <span style="color:#f92672">[</span>free|NUMBER|all<span style="color:#f92672">]</span>                  display the partition table, a partition, or all devices
</span></span><span style="display:flex;"><span>  quit                                     exit program
</span></span><span style="display:flex;"><span>  rescue START END                         rescue a lost partition near START and END
</span></span><span style="display:flex;"><span>  resize NUMBER START END                  resize partition NUMBER and its file system
</span></span><span style="display:flex;"><span>  rm NUMBER                                delete partition NUMBER
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">select</span> DEVICE                            choose the device to edit
</span></span><span style="display:flex;"><span>  set NUMBER FLAG STATE                    change the FLAG on partition NUMBER
</span></span><span style="display:flex;"><span>  toggle <span style="color:#f92672">[</span>NUMBER <span style="color:#f92672">[</span>FLAG<span style="color:#f92672">]]</span>                   toggle the state of FLAG on partition NUMBER
</span></span><span style="display:flex;"><span>  unit UNIT                                set the default unit to UNIT
</span></span><span style="display:flex;"><span>  version                                  displays the current version of GNU Parted and copyright information
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 建立磁盘标签</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>parted<span style="color:#f92672">)</span> mklabel GPT
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 如果没有任何分区，它查看磁盘可用空间，当分区后，它会打印出分区情况</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>parted<span style="color:#f92672">)</span> print
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 创建主分区，n 为要分的分区占整个磁盘的百分比</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>parted<span style="color:#f92672">)</span> mkpart primary 0% 100%
</span></span><span style="display:flex;"><span><span style="color:#75715e">#  分区完后，直接 quit 即可，不像 fdisk 分区的时候，还需要保存一下，这个不用</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>parted<span style="color:#f92672">)</span> quit
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 让内核知道添加新分区</span>
</span></span><span style="display:flex;"><span>partprobe
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 格式化</span>
</span></span><span style="display:flex;"><span>mkfs.ext4 /dev/sdb1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 挂载分区</span>
</span></span><span style="display:flex;"><span>mkdir /data
</span></span><span style="display:flex;"><span>mount /dev/sdb1 /data
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 设置开机自动挂载磁盘</span>
</span></span><span style="display:flex;"><span>vim /etc/fstab
</span></span><span style="display:flex;"><span>/dev/sdb1    /data    ext4    defaults    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># fdisk 命令无法使用可以用 parted</span>
</span></span><span style="display:flex;"><span>fdisk -l
</span></span><span style="display:flex;"><span>parted -l
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># parted 有 2 种模式，使用命令行模式方便自动化</span>
</span></span><span style="display:flex;"><span> 命令行模式: parted <span style="color:#f92672">[</span>option<span style="color:#f92672">]</span> device <span style="color:#f92672">[</span>command<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>交互模式: parted <span style="color:#f92672">[</span>option<span style="color:#f92672">]</span> device
</span></span></code></pre></div><h3 id="23kill命令与信号处理">23.kill命令与信号处理</h3>
<h4 id="1kill命令">1.kill命令</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e"># -l选项告诉kill命令启动进程的用户已注销的方式结束进程 当使用该选项时 kill命令也试图杀死所留下的子进程 但这个命令也不是总能成功 </span>
</span></span><span style="display:flex;"><span>$ kill -l pid
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 强大又危险 这个命令迫使进程在运行时突然停止 进程在结束后不能自我清理 危害是导致系统资源无法正常释放 一般不推荐使用</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 当使用该命令时，一定要通过ps -ef确认没有剩余任何僵尸进程 只能通过终止父进程来消除僵尸进程 如果僵尸进程被init收养 问题就比较严重了 杀死init进程意味着关闭系统 如果系统中有僵尸进程 并且父进程是init 僵尸进程占用了大量的系统资源 那么就需要在某个时候重启机器清除进程表了</span>
</span></span><span style="display:flex;"><span>$ kill -9 pid
</span></span></code></pre></div><h4 id="2linux-signal">2.Linux Signal</h4>
<h5 id="1发送信号">1.发送信号</h5>
<ul>
<li>Ctrl-C发送INT signal（SIGINT),通常导致进程结束</li>
<li>Ctrl-Z发送TSTP signal（SIGSTP),通常导致进程挂起（suspend）</li>
<li>Ctrl-\发送QUIT signal(SIGQUIT),通常导致进程结束和dump core</li>
<li>Ctrl-T(不是所有的unix都支持)发送INFO signal(SIGINFO),导致操作系统显示此运行命令的信息</li>
</ul>
<p><code>kill -9 pid</code>发送SIGKILL信号给进程</p>
<h5 id="2处理信号">2.处理信号</h5>
<p>Signal handler可以通过<code>signal()</code>系统调用进行设置。如果没有设置，缺省的handler会被调用，当然进程也可以忽略此信号。</p>
<p>有两种信号不能被拦截和处理：<code>SIGKILL</code>和<code>SIGSTOP</code></p>
<p>当接受到信号时，进程会根据信号的响应动作执行相应的操作，信号的响应动作有以下几种：</p>
<ul>
<li>中止进程(Term)</li>
<li>忽略信号(lgn)</li>
<li>中止进程并保存内存信息(Core)</li>
<li>停止进程(Stop)</li>
<li>继续运行进程(Cont)</li>
</ul>
<p>用户可以通过<code>signal</code>或<code>sigaction</code>函数修改信号的响应动作（也就是常说的“注册信号”）。另外，在多线程中，各线程的信号响应动作都是相同的，不能对某一个线程设置独立的响应动作。</p>
<h5 id="3信号类型">3.信号类型</h5>
<p>常用的信号</p>
<table>
  <thead>
      <tr>
          <th style="text-align: center">信号</th>
          <th style="text-align: center">值</th>
          <th style="text-align: center">动作</th>
          <th style="text-align: center">说明</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center">SIGHUP</td>
          <td style="text-align: center">1</td>
          <td style="text-align: center">Term</td>
          <td style="text-align: center">终端控制进程结束（终端连接断开）</td>
      </tr>
      <tr>
          <td style="text-align: center">SIGINT</td>
          <td style="text-align: center">2</td>
          <td style="text-align: center">Term</td>
          <td style="text-align: center">用户发送INTR字符（Ctrl+C）触发</td>
      </tr>
      <tr>
          <td style="text-align: center">SIGQUIT</td>
          <td style="text-align: center">3</td>
          <td style="text-align: center">Core</td>
          <td style="text-align: center">用户发送QUIT字符（Ctrl+/）触发</td>
      </tr>
      <tr>
          <td style="text-align: center">SIGILL</td>
          <td style="text-align: center">4</td>
          <td style="text-align: center">Core</td>
          <td style="text-align: center">非法指令</td>
      </tr>
      <tr>
          <td style="text-align: center">SIGABRT</td>
          <td style="text-align: center">6</td>
          <td style="text-align: center">Core</td>
          <td style="text-align: center">调用abort函数触发</td>
      </tr>
      <tr>
          <td style="text-align: center">SIGKILL</td>
          <td style="text-align: center">9</td>
          <td style="text-align: center">Term</td>
          <td style="text-align: center">无条件结束进程（不能被捕获、阻塞或忽略）</td>
      </tr>
      <tr>
          <td style="text-align: center">SIGTERM</td>
          <td style="text-align: center">15</td>
          <td style="text-align: center">Term</td>
          <td style="text-align: center">结束进程（可以被捕获、阻塞、忽略）</td>
      </tr>
      <tr>
          <td style="text-align: center">SIGSTOP</td>
          <td style="text-align: center">17,19,23</td>
          <td style="text-align: center">Stop</td>
          <td style="text-align: center">停止进程（不能被捕获、阻塞、忽略）</td>
      </tr>
      <tr>
          <td style="text-align: center">SIGSTP</td>
          <td style="text-align: center">18,20,24</td>
          <td style="text-align: center">Stop</td>
          <td style="text-align: center">停止进程（可以捕获、阻塞、忽略）</td>
      </tr>
  </tbody>
</table>
<p>参考文章：https://colobu.com/2015/10/09/Linux-Signals/</p>
<h3 id="24-文件描述符">24. 文件描述符</h3>
<p>linux系统中通常会对每个进程所能打开的文件数量有一个限制 当进程中已经打开的文件描述符超过这个限制时 open（）等获取文件描述符的系统调用会返回失败</p>
<p>linux下最大文件描述符限制有两个方面 一个事用户级的限制 另一个是系统级限制</p>
<ul>
<li>用户级限制：ulimit命令可以看到用户级最大文件描述符限制 也就说每一个用户登录后执行的程序占用文件描述符的总数不能超过这个限制</li>
<li>系统级限制：使用 sysctl命令和proc文件系统中查看到的数值是一样的 这个属于系统级限制 他是限制所有用户打开文件描述符的总和</li>
</ul>
<p>查看用户级</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ ulimit -n
</span></span></code></pre></div><p>查看系统级</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ sysctl -a | grep file-max
</span></span><span style="display:flex;"><span>$ cat /proc/sys/fs/file-max
</span></span></code></pre></div><p>修改</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e">#临时修改 用户级</span>
</span></span><span style="display:flex;"><span>$ ulimit -SHn <span style="color:#ae81ff">2048</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#永久修改 用户级</span>
</span></span><span style="display:flex;"><span>$ vi /etc/security/limits.conf
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#修改系统级别限制</span>
</span></span><span style="display:flex;"><span>通过sysctl命令 修改/etc/sysctl.conf文件： sysctl -w fs.file-max<span style="color:#f92672">=</span>2048, 完成后执行 sysctl -p 即可
</span></span></code></pre></div><p>参考文章： <a href="https://www.jianshu.com/p/20f1e96557e3">https://www.jianshu.com/p/20f1e96557e3</a></p>
<h4 id="打开文件表">打开文件表</h4>
<p>内核会维护系统内所有打开的文件及其相关的元信息，该结构称为打开文件表</p>
<p>表中每个条目包括：</p>
<ul>
<li>文件的偏移量。posixAPI中的read write lseek函数都会修改该值</li>
<li>打开文件时的状态和权限标记。通过open函数的参数传入</li>
<li>文件的访问模式（读写执行）。通过open函数的参数传入</li>
<li>指向其对应的inode对象的指针。内核会维护系统级别的inode表</li>
</ul>
<p>文件描述符表、打开文件表、inode表之间的关系可以用书中的下图来表示</p>
<p><img src="/image/file-describers.jpg" alt=""></p>
<h3 id="epoll机制">epoll机制</h3>
<p><a href="https://segmentfault.com/a/1190000003063859">https://segmentfault.com/a/1190000003063859</a></p>
<h3 id="25linux的inotify机制">25.linux的inotify机制</h3>
<p>自内核2.6.13起，linux提供inotify机制，以允许应用程序监控文件事件</p>
<p>队列限制和/proc文件</p>
<ul>
<li>
<p>对inotify事件做排队处理 需要消耗内核内存 正因如此 内核会对inotify机制的操作实施各种限制 超级用户可以配置/proc/sys/fs/inotify路径三个文件调整限制</p>
<ol>
<li>
<p>max_queued_events</p>
<p>调用inotify_init()时，使用该值为新inotify实例队列中的事件数量设置上限 一旦超出这个上限 系统将生成IN_Q_OVERFLOW事件 并丢弃多余的事件 溢出事件的wd字段值为-1</p>
</li>
<li>
<p>max_user_instances</p>
<p>对由每个真实用户ID创建的inotify实例数的限制值</p>
<p>设置值的方法（ sysctl -w fs.inotify.max_user_watches=&ldquo;99999999&rdquo; ）</p>
</li>
<li>
<p>max_user_watches</p>
<p>对由每个真实用户ID创建的监控项数量的限制值</p>
</li>
</ol>
</li>
</ul>
<h3 id="26crontab">26.crontab</h3>
<p><img src="/image/linux/crontab.png" alt=""></p>
<h3 id="27-firewall-常用操作">27. firewall 常用操作</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e">#对外暴露端口</span>
</span></span><span style="display:flex;"><span>$ firewall-cmd --permanent --add-port<span style="color:#f92672">=</span><span style="color:#ae81ff">8080</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#只允许某一个网段访问主机的某一个端口</span>
</span></span><span style="display:flex;"><span>$ firewall-cmd --permanent --add-rich-rule<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;rule family=&#34;</span>ipv4<span style="color:#e6db74">&#34; source address=&#34;</span>1.1.1.1/24<span style="color:#e6db74">&#34; port protocol=&#34;</span>tcp<span style="color:#e6db74">&#34; port=&#34;</span>3306<span style="color:#e6db74">&#34; accept&#34;</span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e">#reload</span>
</span></span><span style="display:flex;"><span>$ firewalld-cmd --reload
</span></span><span style="display:flex;"><span><span style="color:#75715e">#端口转发，将到本机的3306端口的访问转发到192.168.1.1服务器的3306端口</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#开启伪装IP</span>
</span></span><span style="display:flex;"><span>$ firewalld-cmd --permanent --add-masquerade
</span></span><span style="display:flex;"><span><span style="color:#75715e">#配置端口转发</span>
</span></span><span style="display:flex;"><span>$ firewalld-cmd --permanent --add-forward-port<span style="color:#f92672">=</span>3306:proto<span style="color:#f92672">=</span>tcp:toaddr<span style="color:#f92672">=</span>192.168.1.1.2:toport<span style="color:#f92672">=</span><span style="color:#ae81ff">13306</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#查看状态</span>
</span></span><span style="display:flex;"><span>$ firewalld-cmd --state
</span></span><span style="display:flex;"><span><span style="color:#75715e">#查看规则</span>
</span></span><span style="display:flex;"><span>$ firewalld-cmd --list-all
</span></span><span style="display:flex;"><span><span style="color:#75715e">#查看所有的防火墙策略</span>
</span></span><span style="display:flex;"><span>$ firewalld-cmd --list-all-zones
</span></span><span style="display:flex;"><span><span style="color:#75715e">#重新加载配置文件</span>
</span></span><span style="display:flex;"><span>$ firewalld-cmd --reload
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#查看所有打开的端口： firewall-cmd --zone=public --list-ports</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#查看区域信息:  firewall-cmd --get-active-zones</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#查看指定接口所属区域： firewall-cmd --get-zone-of-interface=eth0</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#拒绝所有包: firewalld-cmd --panic-on</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#取消拒绝状态： firewalld-cmd --panic-off</span>
</span></span></code></pre></div><h3 id="28nmap">28.nmap</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>nmap -sP -PR 192.168.0.0/24
</span></span></code></pre></div><h3 id="29linux常用命令">29.linux常用命令</h3>
<ul>
<li><strong>netstat</strong></li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>-n 直接使用ip地址
</span></span><span style="display:flex;"><span>-l 显示监控中服务器的socket
</span></span><span style="display:flex;"><span>-p 显示正在使用socket程序识别码和进程名称
</span></span><span style="display:flex;"><span>-t tcp
</span></span><span style="display:flex;"><span>-u udp
</span></span></code></pre></div><ul>
<li><strong>ps</strong></li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-BASH" data-lang="BASH"><span style="display:flex;"><span>-A 显示所有进程 <span style="color:#f92672">==</span> -e
</span></span><span style="display:flex;"><span>f 显示进程间的关系
</span></span><span style="display:flex;"><span>--lines 一页显示多少行
</span></span><span style="display:flex;"><span>aux 列出所有正在内存当中的程序
</span></span></code></pre></div><ul>
<li><strong>free</strong></li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e">#可以显示linux系统中空闲的和正在使用的物理内存 swap内存以及被内核使用的buffer</span>
</span></span><span style="display:flex;"><span>-m 　以MB为单位显示内存使用情况
</span></span><span style="display:flex;"><span>-t 　显示内存总和列
</span></span><span style="display:flex;"><span>-h   易懂的方式输出
</span></span></code></pre></div><ul>
<li><strong>du</strong></li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e">#显示每个目录或文件使用的磁盘空间</span>
</span></span><span style="display:flex;"><span>-h 人性化输出
</span></span></code></pre></div><ul>
<li><strong>top</strong></li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e">#top命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况，类似于Windows的任务管理器</span>
</span></span><span style="display:flex;"><span>PID   进程id
</span></span><span style="display:flex;"><span>USER  进程所有者
</span></span><span style="display:flex;"><span>PR    进程优先级
</span></span><span style="display:flex;"><span>NI    nice值
</span></span><span style="display:flex;"><span>VIRT  进程使用的虚拟内存总量
</span></span><span style="display:flex;"><span>RES   进程使用的 未被换出的物理内存大小
</span></span><span style="display:flex;"><span>S     进程状态 D不可中断的睡眠状态 R运行 S睡眠  T跟踪/停止 Z僵尸进程
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>-d   每隔几秒显示所有进程占用情况
</span></span><span style="display:flex;"><span>-p   显示某一个进程的资源使用情况
</span></span></code></pre></div><ul>
<li>python</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>echo <span style="color:#e6db74">&#39;{&#34;name&#34;:&#34;chen&#34;,&#34;age&#34;:&#34;11&#34;}&#39;</span> |python -m json.tool
</span></span></code></pre></div><h3 id="30linux状态码的意义">30.LInux状态码的意义</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>0		命令成功结束
</span></span><span style="display:flex;"><span>1		通用未知错误
</span></span><span style="display:flex;"><span>2		误用shell命令
</span></span><span style="display:flex;"><span>126		命令不可执行
</span></span><span style="display:flex;"><span>127		没有找到命令
</span></span><span style="display:flex;"><span>128		无效退出命令
</span></span><span style="display:flex;"><span>128+x	Linux信号x的严重错误
</span></span><span style="display:flex;"><span>130		Linux信号2的严重错误 即命令通过SIGINT<span style="color:#f92672">(</span>Ctrl+C<span style="color:#f92672">)</span>终止
</span></span><span style="display:flex;"><span>255		退出状态码越界
</span></span></code></pre></div><h3 id="31一些有用的linux命令">31.一些有用的linux命令</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e">#sort 排序</span>
</span></span><span style="display:flex;"><span>ls -all | sort -nk5
</span></span><span style="display:flex;"><span><span style="color:#75715e">#-n字符串按数值比较 -k表示第几列</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#shuf 乱序输入文件的行</span>
</span></span><span style="display:flex;"><span>echo -e <span style="color:#e6db74">&#39;a\nb\nc&#39;</span> | shuf
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#uniq 前提是内容已经排序 -c用来计数 -u用来只显示不重复的内容 -d用来只显示重复的内容</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#join  </span>
</span></span><span style="display:flex;"><span>https://my.oschina.net/tinyhare/blog/828320
</span></span></code></pre></div><h3 id="32tar命令">32.tar命令</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e">#打包命令</span>
</span></span><span style="display:flex;"><span>tar -cvf test.tar a b c d
</span></span><span style="display:flex;"><span><span style="color:#75715e">#解压命令</span>
</span></span><span style="display:flex;"><span>tar -xvf test.tar
</span></span></code></pre></div><h3 id="33-docker-安装-yapi">33. docker 安装 yapi</h3>
<p><code>https://blog.csdn.net/Dream_xun/article/details/106986677</code></p>
<h3 id="34软连接">34.软连接</h3>
<pre tabindex="0"><code>由于目录有存储空间限制，当存储空间不足时，可以使用软链接缓解空间不足的问题：将文件内容移动到较大空间的目录内，使用ln命令建立实际存储路径与虚拟访问路径的软链接（需要root用户登录）：

移动文件夹至实际存储路径,前一个为原路径，后一个为目的路径：

 mv /usr/share/nginx/html/nextcloud/data /data4/nextcloud/

建立软链接，前一个为实际存储路径，后一个为虚拟访问路径，两者权限相同：

ln -s /data4/nextcloud/data /usr/share/nginx/html/nextcloud/data
</code></pre><h3 id="35查看网卡是否为万兆卡">35.查看网卡是否为万兆卡</h3>
<p><code>lspci -vvv | grep Ethernet</code></p>
<h3 id="36thread-died-in-berkeley-db-library">36.Thread died in Berkeley DB library</h3>
<h4 id="问题解决">问题解决</h4>
<p>　　01、删除yum临时库文件</p>
<p>　　　　rm -fr /var/lib/rpm/__db.*</p>
<p>　　02、重建rpm数据库</p>
<p>　　　　rpm &ndash;rebuilddb</p>
<p>　　03、清理缓存及生产yumdb缓存</p>
<p>　　　　yum clean all</p>
<p>　　　　yum makecache</p>
<h3 id="37-linux中的中断信号">37. linux中的中断信号</h3>
<p>信号（signal）是linux，类unix和其他posix兼容的操作系统中用来进程间通信的一种方式。一个信号就是一个异步的通知，发送给某个进程，或者同进程的某个线程，告诉它们某个事件发生了</p>
<p>当信号发送到某个进程中时，操作系统会中断该进程的正常流程，并进入相应的信号处理函数执行操作，完成后再刚回到中断的地方继续执行。</p>
<table>
  <thead>
      <tr>
          <th style="text-align: left">信号</th>
          <th style="text-align: left">值</th>
          <th style="text-align: left">动作</th>
          <th style="text-align: left">说明</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left">SIGHUP</td>
          <td style="text-align: left">1</td>
          <td style="text-align: left">Term</td>
          <td style="text-align: left">终端控制进程结束(终端连接断开)</td>
      </tr>
      <tr>
          <td style="text-align: left">SIGINT</td>
          <td style="text-align: left">2</td>
          <td style="text-align: left">Term</td>
          <td style="text-align: left">用户发送INTR字符(Ctrl+C)触发</td>
      </tr>
      <tr>
          <td style="text-align: left">SIGQUIT</td>
          <td style="text-align: left">3</td>
          <td style="text-align: left">Core</td>
          <td style="text-align: left">用户发送QUIT字符(Ctrl+/)触发</td>
      </tr>
      <tr>
          <td style="text-align: left">SIGILL</td>
          <td style="text-align: left">4</td>
          <td style="text-align: left">Core</td>
          <td style="text-align: left">非法指令(程序错误、试图执行数据段、栈溢出等)</td>
      </tr>
      <tr>
          <td style="text-align: left">SIGABRT</td>
          <td style="text-align: left">6</td>
          <td style="text-align: left">Core</td>
          <td style="text-align: left">调用abort函数触发</td>
      </tr>
      <tr>
          <td style="text-align: left">SIGFPE</td>
          <td style="text-align: left">8</td>
          <td style="text-align: left">Core</td>
          <td style="text-align: left">算术运行错误(浮点运算错误、除数为零等)</td>
      </tr>
      <tr>
          <td style="text-align: left">SIGKILL</td>
          <td style="text-align: left">9</td>
          <td style="text-align: left">Term</td>
          <td style="text-align: left">无条件结束程序(不能被捕获、阻塞或忽略)</td>
      </tr>
      <tr>
          <td style="text-align: left">SIGSEGV</td>
          <td style="text-align: left">11</td>
          <td style="text-align: left">Core</td>
          <td style="text-align: left">无效内存引用(试图访问不属于自己的内存空间、对只读内存空间进行写操作)</td>
      </tr>
      <tr>
          <td style="text-align: left">SIGPIPE</td>
          <td style="text-align: left">13</td>
          <td style="text-align: left">Term</td>
          <td style="text-align: left">消息管道损坏(FIFO/Socket通信时，管道未打开而进行写操作)</td>
      </tr>
      <tr>
          <td style="text-align: left">SIGALRM</td>
          <td style="text-align: left">14</td>
          <td style="text-align: left">Term</td>
          <td style="text-align: left">时钟定时信号</td>
      </tr>
      <tr>
          <td style="text-align: left">SIGTERM</td>
          <td style="text-align: left">15</td>
          <td style="text-align: left">Term</td>
          <td style="text-align: left">结束程序(可以被捕获、阻塞或忽略)</td>
      </tr>
      <tr>
          <td style="text-align: left">SIGUSR1</td>
          <td style="text-align: left">30,10,16</td>
          <td style="text-align: left">Term</td>
          <td style="text-align: left">用户保留</td>
      </tr>
      <tr>
          <td style="text-align: left">SIGUSR2</td>
          <td style="text-align: left">31,12,17</td>
          <td style="text-align: left">Term</td>
          <td style="text-align: left">用户保留</td>
      </tr>
      <tr>
          <td style="text-align: left">SIGCHLD</td>
          <td style="text-align: left">20,17,18</td>
          <td style="text-align: left">Ign</td>
          <td style="text-align: left">子进程结束(由父进程接收)</td>
      </tr>
      <tr>
          <td style="text-align: left">SIGCONT</td>
          <td style="text-align: left">19,18,25</td>
          <td style="text-align: left">Cont</td>
          <td style="text-align: left">继续执行已经停止的进程(不能被阻塞)</td>
      </tr>
      <tr>
          <td style="text-align: left">SIGSTOP</td>
          <td style="text-align: left">17,19,23</td>
          <td style="text-align: left">Stop</td>
          <td style="text-align: left">停止进程(不能被捕获、阻塞或忽略)</td>
      </tr>
      <tr>
          <td style="text-align: left">SIGTSTP</td>
          <td style="text-align: left">18,20,24</td>
          <td style="text-align: left">Stop</td>
          <td style="text-align: left">停止进程(可以被捕获、阻塞或忽略)</td>
      </tr>
      <tr>
          <td style="text-align: left">SIGTTIN</td>
          <td style="text-align: left">21,21,26</td>
          <td style="text-align: left">Stop</td>
          <td style="text-align: left">后台程序从终端中读取数据时触发</td>
      </tr>
      <tr>
          <td style="text-align: left">SIGTTOU</td>
          <td style="text-align: left">22,22,27</td>
          <td style="text-align: left">Stop</td>
          <td style="text-align: left">后台程序向终端中写数据时触发</td>
      </tr>
  </tbody>
</table>
<h3 id="38core文件">38.core文件</h3>
<p>在程序不寻常退出时，内核会在当前工作目录下生成一个core文件（是一个内存映像，同时加上调试信息）。使用gdb来查看core文件，可以指示出导致程序出错的代码所在文件和行数。</p>
<p>通过ulimit -c可以查看core文件的大小。0位关闭</p>
<h3 id="39mlocate文件过大问题">39.mlocate文件过大问题</h3>
<p><strong>locate</strong>命令用来查找文件和目录。locate命令要比find -name快得多，原因在于它不搜索具体目录，而是搜索一个数据库/var/lib/mlocate/mlocate.db。这个数据库包含本地所有文件信息。系统自动创建这个数据库，并且每天更新一次。使用updatedb命令，手动更新数据库。</p>
<p>mlocate.db文件过大解决办法</p>
<p>1.修改/etc/updatedb.conf  在	PRUNEPATHS参数后面增加不需要进行locate的目录。修改后执行</p>
<p><code>sudo pkill updatedb.mlocate</code></p>
<p><code>updatedb</code></p>
<h3 id="40netstat与lsof">40.netstat与lsof</h3>
<h4 id="netstat">netstat</h4>
<p>（https://blog.csdn.net/LiuXingSiYe/article/details/86539480）</p>
<p>常用参数：</p>
<p>-a： 显示所有链接</p>
<p>-n：直接使用IP地址，而不通过域名服务器</p>
<p>-o： 显示计时器</p>
<p>-p：显示正在使用socket的程序识别码和程序名称</p>
<p>-l：显示监控中的服务器的socket</p>
<p>常用技巧：</p>
<ul>
<li>查找请求最多的前20个ip（常用于查找攻击开源）</li>
</ul>
<p><code>netstat -anlp|grep 80|grep tcp|awk '{print $5}'|awk -F: '{print $1}'|sort|uniq -c|sort -nr|head -n20</code></p>
<p><code>netstat -ant |awk '/:80/{split($5,ip,&quot;:&quot;);++A[ip[1]]}END{for(i in A) print A[i],i}' |sort -rn|head -n20</code></p>
<h4 id="lsof">lsof</h4>
<p>lsof -i:[端口号]</p>
<p>lsof -i:8080：查看8080端口占用
lsof abc.txt：显示开启文件abc.txt的进程
lsof -c abc：显示abc进程现在打开的文件
lsof -c -p 1234：列出进程号为1234的进程所打开的文件
lsof -g gid：显示归属gid的进程情况
lsof +d /usr/local/：显示目录下被进程开启的文件
lsof +D /usr/local/：同上，但是会搜索目录下的目录，时间较长
lsof -d 4：显示使用fd为4的进程
lsof -i -U：显示所有打开的端口和UNIX domain文件</p>
<h3 id="41iptables">41.iptables</h3>
<h4 id="增加白名单">增加白名单</h4>
<p>配置22端口的白名单 -s 指定源</p>
<p><code>iptables -A INPUT -s 192.168.1.0/24 -p tcp --dport 22 -j ACCEPT </code></p>
<p>这个放到最后提条（-A参数表示放到队首，-I表示放到最后。iptables由上往下匹配，一旦符合，后面都不匹配）</p>
<p><code>iptables -A INPUT -p tcp --dport 22 -j DROP</code></p>
<pre tabindex="0"><code>iptables -L INPUT -n --line-number #列出所有INPUT规则
iptables -D INPUT 4 # 删除第四条规则
</code></pre><ul>
<li>查询：iptables [-t table] [-L] [-nv]</li>
</ul>
<p>-t ：nat filter mangle</p>
<p>-L：PROROUTING INPUT FORWARD OUTPUT POSTROUTING</p>
<p>-n：直接显示ip，速度回快些</p>
<p>-v：列出更多信息，包括通过该规则的数据包总位数、相关的网络接口</p>
<ul>
<li>清除：iptables [-t tables] [-FXZ]</li>
</ul>
<p>-F: 清除所有已经制定的规则</p>
<p>-X：删除所有使用者自定义的chain</p>
<p>-Z：将所有的chain的计数与流量统计都清零</p>
<h3 id="42sed命令">42.sed命令</h3>
<pre tabindex="0"><code class="language- " data-lang=" ">sed -e &#39;/abc/d&#39; a.log #删除a.log中包含‘abc’的行，但不改变a.log本身，操作之后的结果显示在终端
sed -e ‘/abc/d’ a.log &gt; a.log.bak #删除a.logzhong包含 ‘abc’的行，将结果保存到a.log.bak
sed &#39;/abc/d;/efg/d&#39; a.log &gt; a.log.bak #删除含字符串 ‘abc’或‘efg’的行
sed -i &#39;s/test/mytest/g&#39; example #把test替换成mytest -i 是直接修改并保存
</code></pre><h3 id="43查看磁盘io">43.查看磁盘io</h3>
<h4 id="top命令">top命令</h4>
<pre tabindex="0"><code>Tasks: 103 total,   2 running, 101 sleeping,   0 stopped,   0 zombie
%Cpu(s):  0.3 us,  0.3 sy,  0.0 ni, 99.0 id,  0.0 wa,  0.3 hi,  0.0 si,  0.0 st
</code></pre><p>Tasks:</p>
<p>103 total 进程总数</p>
<p>2 running 正在运行的进程数</p>
<p>101 sleeping 睡眠的进程数</p>
<p>0 stopped 停止的进程数</p>
<p>0 zombie 僵尸进程数</p>
<p>%Cpu(s):</p>
<p>0.3 us 用户空间占用cpu百分比</p>
<p>0.3 sy 内核空间占用cpu百分比</p>
<p>0.0 ni 用户进程空间内改变过优先级的进程占用cpu百分比</p>
<p>99.0 id 空闲cpu百分比</p>
<p>0.0 wa 等待输入输出的cpu时间百分比</p>
<p>0.3 hi</p>
<h4 id="iostat">iostat</h4>
<p>iostat -dx</p>
<h4 id="清理-varlogjournal">清理 /var/log/journal</h4>
<p><code>journalctl --vacuum-size=10M</code></p>
<h3 id="44-centos查看用户和用户组">44. centos查看用户和用户组</h3>
<ul>
<li>
<p>查看用户列表：<code>cat /etc/passwd</code></p>
</li>
<li>
<p>查看用户组列表 <code>cat /etc/group</code></p>
</li>
<li>
<p>查看系统中有哪些用户 <code>cut -d : -f 1 /etc/passwd</code></p>
</li>
<li>
<p>查看可以登陆系统的用户 <code>cat /etc/passwd | grep -v /sbin/nologin |cut -d : -f 1</code></p>
</li>
<li>
<p>查看用户操作权限： <code>w</code></p>
</li>
<li>
<p>查看某一个用户 <code>w &lt;user&gt;</code></p>
</li>
</ul>
<h3 id="45-创建用户指定家目录">45. 创建用户指定家目录</h3>
<p>linux创建新用户，当前用户必须为root用户</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>useradd <span style="color:#f92672">-</span>d <span style="color:#f92672">/</span>export<span style="color:#f92672">/</span>gaoxin <span style="color:#f92672">-</span>m gaoxin
</span></span></code></pre></div><h3 id="46-iperf-用法">46. iperf 用法</h3>
<h4 id="1-查看当前节点的网速">1. 查看当前节点的网速</h4>
<p><code>iptraf -g</code></p>
<h4 id="2-iperf3">2. iperf3</h4>
<p>常用参数：</p>
<p>-s –server 服务器模式</p>
<p>-c –client 客户端模式</p>
<p>-i  指定每次报告之间的时间间隔</p>
<p>-p 端口</p>
<p>-u –udp 表示采用UDP协议发送报文</p>
<p>-l  设置读写缓冲区的长度</p>
<p>-b –bandwidth 指定UDP模式使用的带宽</p>
<p>-t 	指定数据传输的总时间</p>
<p>-F   指定文件作为数据流进行带宽测试</p>
<h3 id="47-bond策略">47. bond策略</h3>
<ul>
<li>bond0 : round-robin : 轮询</li>
<li>bond1 : active-backup: 主备</li>
<li>bond2: XOR: hash负载均衡</li>
<li>bond3: broadcast: 广播策略，向所有的接口发送数据包，本模式提供容错能力</li>
<li>bond4: 802.3ad: 动态链路聚合</li>
<li>bond5: balance-tlb: 自适应传输负载均衡，根据每个slave的负载决定从哪个接口发送数据包，从哪个接口接受数据包。如果接收的slave接口故障，其他slave接口将接管它的mac地址继续接收。</li>
<li>bond6: balance-alb: 自适应负载均衡</li>
</ul>
<p>注意： mode1 5 6 不需要交换机配置 mode0 2 3 4 需要交换机配置</p>
<h3 id="ping不通几种情况">ping不通几种情况</h3>
<h4 id="常见原因">常见原因：</h4>
<ul>
<li>ip错误</li>
<li>网段不同 通过路由无法找到</li>
<li>防火墙设置</li>
<li>路由设置问题</li>
</ul>
<p>排查方法：</p>
<ul>
<li>
<p>ping -a 可探测对方</p>
</li>
<li>
<p>ping 127.0.0.1</p>
<ul>
<li>若提示： no route to host 则说明网卡不能正常工作</li>
<li>若提示：transmit failed error code 则说明网卡驱动有问题</li>
<li>若提示：timeout 说明路由器中有该路由，但是由于其他原因导致包无法送达</li>
<li>若提示： destination host unreachable 说明路由器中无该路由</li>
</ul>
</li>
<li>
<p>查看主机的路由规则 route -n 看看是否有问题</p>
</li>
</ul>
<h4 id="操作方法删除路由">操作方法（删除路由）</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ route -n
</span></span><span style="display:flex;"><span>Kernel IP routing table
</span></span><span style="display:flex;"><span>Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
</span></span><span style="display:flex;"><span>0.0.0.0         192.168.178.1   0.0.0.0         UG    <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>        <span style="color:#ae81ff">0</span> eth0
</span></span><span style="display:flex;"><span>0.0.0.0         160.98.123.1    0.0.0.0         UG    <span style="color:#ae81ff">600</span>    <span style="color:#ae81ff">0</span>        <span style="color:#ae81ff">0</span> wlan0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ sudo route del -n 0.0.0.0 gw 192.168.178.1 netmask 0.0.0.0 dev eth0
</span></span></code></pre></div><h4 id="删除网桥">删除网桥</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e"># 删除网卡</span>
</span></span><span style="display:flex;"><span>$ tunctl -d &lt;vir interface&gt;
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 删除虚拟网桥</span>
</span></span><span style="display:flex;"><span>$ ifconfig brige down
</span></span><span style="display:flex;"><span>$ brctl delbr brige
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 将网卡 移出 bridge</span>
</span></span><span style="display:flex;"><span>$ brctl delif br0 veth
</span></span></code></pre></div><h3 id="nohup用法以及含义">nohup用法以及&amp;含义</h3>
<p><code>nohup ./my_script &gt; my_script.log 2&gt;&amp;1 &amp;</code></p>
<p>在命令最后加上&amp;符号，表示让这个进程到后台去执行，这样立刻返回到提示符状态，我们可以接着做下面的事。如：command &amp;。
这种“后台”进程在shell一直打开的情况下是没有问题的，如果我们关了shell窗口甚至退出ssh登录或vnc登录，那么进程自动就结束了。所以如果想退出窗口乃至退出登录仍然保持程序运行，再加上nohup。</p>
<h3 id="升级centos内核">升级centos内核</h3>
<h4 id="内核含义">内核含义</h4>
<p>版本性质：ml(mainline)主分支，stable稳定版，lt(longterm)长期维护版</p>
<p>查看当前内核版本：<code>uname -r</code></p>
<h4 id="升级内核">升级内核</h4>
<ol>
<li>升级内核需先倒入elrepo的key，然后安装elrepo的yum源：</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org
</span></span><span style="display:flex;"><span>yum install -y https://www.elrepo.org/elrepo-release-7.0-4.el7.elrepo.noarch.rpm
</span></span></code></pre></div><ol start="2">
<li>安装ml内核</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>yum --enablerepo<span style="color:#f92672">=</span>elrepo-kernel -y install kernel-ml-devel kernel-ml
</span></span><span style="display:flex;"><span><span style="color:#75715e">#安装lt</span>
</span></span><span style="display:flex;"><span>yum --enablerepo<span style="color:#f92672">=</span>elrepo-kernel -y install kernel-lt-devel kernel-lt
</span></span></code></pre></div><ol start="3">
<li>设置为默认内核</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>grub2-set-default <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>gurb2-mkconfig -o /boot/grub2/grub.cfg
</span></span></code></pre></div><ol start="4">
<li>删除旧的内核</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>rpm -qa | grep kernel
</span></span><span style="display:flex;"><span>yum remove 旧内核名字
</span></span></code></pre></div><ol start="5">
<li>安装新的工具包</li>
</ol>
<pre tabindex="0"><code>yum remove kernel-tools-libs kernel-tools -y
#install new version
yum --disablerepo=* --enablerepo=elrepo-kernel install kernel-ml-tools
</code></pre><ol start="6">
<li><code>reboot</code></li>
</ol>
<h3 id="linux进程状态">linux进程状态</h3>
<p>R（TASK_RUNNING），可执行状态</p>
<p>只有在该状态下才可能在cpu上运行。而同一时刻可能有多个进程状态处于可执行状态。这些进程的task_struct结构（进程控制块）被放入对应的cpu的可执行队列中。进程调度器的任务就是从各个cpu的可执行队列中选择一个进程放在该cpu上运行。</p>
<p>S（TASK_INTERRUPTIBLE）可中断的睡眠状态。</p>
<p>处于该状态的进程因为等待某个事件发生（比如等待socket连接，等待信号量）而被挂起。这些进程task_struct结构被放入对应的事件的等待队列中。这些事件发生时，对应的等待队列中的一个或多个进程将被唤醒。</p>
<p>D（TASK_UNINTERRUPTIBLE），不可中断的睡眠状态</p>
<p>不可中断是指进程不响应异步信号。并不是cpu不响应外部硬件的中断。</p>
<p>参考文章：https://www.cnblogs.com/klb561/p/11945157.html</p>
<h3 id="find命令">find命令</h3>
<p>命令格式：</p>
<p><code>find [-H] [-L] [-P] [-D debugopts] [-Olevel] [path...] [expression]</code></p>
<ul>
<li><code>[-H] [-L] [-P] [-D debugopts] [-Olevel]</code>这部分属于命令选项，比较少用</li>
<li><code>[path...]</code> 该参数指定要查找的饭目录，可以同时提供多个目录用空格隔开。可以提供一个文件名，只在当前目录下查找该文件，不会在子目录中查找</li>
<li><code>[expression]</code> 该参数指定评估表达式，可以提供多个，不用表达式之间用operator（-o -a -not）操作符分开，表达式有option、test、action三种类型。如果不提供该参数，默认使用-print表达式，也就是打印出所给出的文件名。表达式参数要求以<code>- ( !  </code>开头，以便区分开前面的目录参数。注意，bash中要用<code>\(</code>转义</li>
</ul>
<h3 id="网卡设置为混杂模式">网卡设置为混杂模式</h3>
<pre tabindex="0"><code>ifconfig eth0 promisc
</code></pre><h3 id="linux系统卡顿排查">linux系统卡顿排查</h3>
<h4 id="1-内存">1. 内存</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>free -g
</span></span><span style="display:flex;"><span><span style="color:#75715e">#当free这一栏为0 说明内存吃完了</span>
</span></span></code></pre></div><h4 id="2磁盘用量和io">2.磁盘用量和io</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>df -h
</span></span><span style="display:flex;"><span><span style="color:#75715e">#当最右侧%util很高时，说明io很高，若想看哪个进程占用IO，执行iotop命令</span>
</span></span><span style="display:flex;"><span>iostat -x <span style="color:#ae81ff">1</span>
</span></span></code></pre></div><h4 id="3cpu">3.CPU</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>top
</span></span><span style="display:flex;"><span><span style="color:#75715e">#cpu行的%id表示剩余cpu资源，若很低表示cpu资源被吃完了</span>
</span></span></code></pre></div><h4 id="安装python10">安装python10</h4>
<div class="edit-meta"> <br></div><nav class="pagination"><a class="nav nav-prev" href="http://localhost:1313/linux_foundation/linux-commands/" title="50个常用Linux命令"><i class="fas fa-arrow-left" aria-hidden="true"></i>&nbsp;Prev - 50个常用Linux命令</a>
<a class="nav nav-next" href="http://localhost:1313/algorithm/" title="Algorithms">Next - Algorithms <i class="fas fa-arrow-right" aria-hidden="true"></i></a>
</nav><footer> </footer>
</main>
<div class="sidebar">

<nav class="slide-menu">
<ul>
<li class=""><a href="http://localhost:1313/">About Me</a></li>

<li class=""><a href="http://localhost:1313/learn_cs/">自学CS</a>
  
</li>

<li class=""><a href="http://localhost:1313/learn_english/">英语学习</a>
  
</li>

<li class=" has-sub-menu"><a href="http://localhost:1313/math_foundation/">机器学习中的数学<span class="mark closed">+</span></a>
  
<ul class="sub-menu">
<li class=""><a href="http://localhost:1313/math_foundation/information/">信息量</a></li>
<li class=""><a href="http://localhost:1313/math_foundation/%E4%BC%BC%E7%84%B6%E5%87%BD%E6%95%B0_%E4%BA%A4%E5%8F%89%E7%86%B5/">似然函数_交叉熵</a></li>
<li class=""><a href="http://localhost:1313/math_foundation/kl%E6%95%A3%E5%BA%A6%E4%B8%8Edpo%E7%AE%97%E6%B3%95/">Kl散度与dpo算法</a></li>
</ul>
  
</li>

<li class=" has-sub-menu"><a href="http://localhost:1313/transformer/">transformer<span class="mark closed">+</span></a>
  
<ul class="sub-menu">
<li class=""><a href="http://localhost:1313/transformer/do_sample_para/">Do_sample_para</a></li>
<li class=""><a href="http://localhost:1313/transformer/nn_begin/">Nn Begin</a></li>
<li class=""><a href="http://localhost:1313/transformer/entropy/">Entropy</a></li>
</ul>
  
</li>

<li class=" has-sub-menu"><a href="http://localhost:1313/kubernetes/">kubernetes<span class="mark closed">+</span></a>
  
<ul class="sub-menu">
<li class=""><a href="http://localhost:1313/kubernetes/installation/">Installation</a></li>
</ul>
  
</li>

<li class=" has-sub-menu"><a href="http://localhost:1313/golang/">golang<span class="mark closed">+</span></a>
  
<ul class="sub-menu">
<li class=""><a href="http://localhost:1313/golang/foundation/">Foundation</a></li>
<li class=""><a href="http://localhost:1313/golang/base/">Base</a></li>
</ul>
  
</li>

<li class="parent has-sub-menu"><a href="http://localhost:1313/linux_foundation/">Linux基础知识<span class="mark opened">-</span></a>
  
<ul class="sub-menu">
<li class=""><a href="http://localhost:1313/linux_foundation/linux-commands/">50个常用Linux命令</a></li>
<li class="active"><a href="http://localhost:1313/linux_foundation/linux-common/">Linux Common</a></li>
</ul>
  
</li>

<li class=" has-sub-menu"><a href="http://localhost:1313/algorithm/">Algorithms<span class="mark closed">+</span></a>
  
<ul class="sub-menu">
<li class=""><a href="http://localhost:1313/algorithm/dynamic-programmnig/">Dynamic Programming</a></li>
</ul>
  
</li>

<li class=" has-sub-menu"><a href="http://localhost:1313/exercise/">Exercises<span class="mark closed">+</span></a>
  
<ul class="sub-menu">
<li class=""><a href="http://localhost:1313/exercise/workout/">Workout</a></li>
</ul>
  
</li>

<li class=" has-sub-menu"><a href="http://localhost:1313/others/">Others<span class="mark closed">+</span></a>
  
<ul class="sub-menu">
<li class=""><a href="http://localhost:1313/others/create-hugo-gitpage/">使用 Hugo 和 GitHub Pages 创建个人网站</a></li>
</ul>
  
</li>
</ul>
</nav>

 
<div class="sidebar-footer"></div>
</div>

</div><a href="#" id="backtothetop-fixed" class="backtothetop"
 data-backtothetop-duration="600"
 data-backtothetop-easing="easeOutQuart"
 data-backtothetop-fixed-fadeIn="1000"
 data-backtothetop-fixed-fadeOut="1000"
 data-backtothetop-fixed-bottom="10"
 data-backtothetop-fixed-right="20">
<span class="fa-layers fa-fw">
<i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i>
</span></a>
</div>
</body>
</html>
