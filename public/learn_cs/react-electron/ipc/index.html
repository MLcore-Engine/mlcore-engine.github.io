<!DOCTYPE html>
<html lang="zh-cn">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<title>ipc基础 - 高新 | AI平台开发工程师</title>
<meta name="description" content="AI平台开发工程师，专注于AI平台工程和Kubernetes云原生技术。拥有AI平台开发、GPU资源优化和AI服务部署经验">
<meta name="generator" content="Hugo 0.145.0">
<link href="http://localhost:1313//index.xml" rel="alternate" type="application/rss+xml">
<link rel="canonical" href="http://localhost:1313/learn_cs/react-electron/ipc/">
<link rel="stylesheet" href="http://localhost:1313/css/theme.min.css">
<link rel="stylesheet" href="http://localhost:1313/css/chroma.min.css">
<script defer src="http://localhost:1313//js/fontawesome6/all.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js" integrity="sha256-H3cjtrm/ztDeuhCN9I4yh4iN2Ybx/y1RM7rMmAesA0k=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js" integrity="sha256-4XodgW4TwIJuDtf+v6vDJ39FVxI0veC/kSCCmnFp7ck=" crossorigin="anonymous"></script>
<script src="http://localhost:1313/js/bundle.js"></script><style>
 
@media screen and (min-width: 480px) {
  .sidebar {
    flex: 0 0 20% !important;
    max-width: 20% !important;
  }
  
  main {
    flex: 0 0 80% !important;
    max-width: 80% !important;
  }
}

 
body {
  background-color: #f8f5e6 !important;  
  font-family: 'KaiTi', 'STKaiti', '楷体', '楷体_GB2312', 'SimKai', '华文楷体', Kai, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif !important;  
  font-size: 20px !important;  
  line-height: 1.8 !important;  
}

 
.container, .content-container, main {
  background-color: #f8f5e6 !important;
}

 
.sidebar {
  background-color: inherit;
  font-size: 16px !important;  
}

 
h1, h2, h3, h4, h5, h6 {
  font-family: 'KaiTi', 'STKaiti', '楷体', '楷体_GB2312', 'SimKai', '华文楷体', Kai, 'Noto Serif', Georgia, serif !important;
  font-weight: 600 !important;
  line-height: 1.5 !important;
}

 
h1 {
  font-size: 2.4em !important;
}

h2 {
  font-size: 2em !important;
}

h3 {
  font-size: 1.7em !important;
}

h4 {
  font-size: 1.5em !important;
}

h5 {
  font-size: 1.3em !important;
}

h6 {
  font-size: 1.2em !important;
}

 
p {
  font-size: 20px !important;
  margin-bottom: 1.2em !important;
}

 
li {
  font-size: 20px !important;
  margin-bottom: 0.5em !important;
}

 
article, .content, .post-content, main p, main li, main td, main th, blockquote, .markdown {
  font-size: 20px !important;
}

 
pre, code {
  font-family: 'JetBrains Mono', Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace !important;
  font-size: 1.1em !important;  
}

 
a {
  color: #0066cc !important;
  text-decoration: none !important;
}

a:hover {
  text-decoration: underline !important;
}

 
table {
  font-size: 20px !important;
}
</style> <meta property="og:url" content="http://localhost:1313/learn_cs/react-electron/ipc/">
  <meta property="og:site_name" content="高新 | AI平台开发工程师">
  <meta property="og:title" content="ipc基础">
  <meta property="og:description" content="IPC 详细解释 IPC（Inter-Process Communication，进程间通信）是一个广泛的概念，指的是在操作系统中，不同进程之间交换数据和信号的机制。在多任务操作系统中，IPC 非常重要，因为它允许进程协同工作、共享资源或传递信息。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="learn_cs">
    <meta property="article:published_time" content="2025-05-18T09:54:34+08:00">
    <meta property="article:modified_time" content="2025-05-18T11:29:01+08:00">
    <meta property="og:image" content="http://localhost:1313/home/me.png">

  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:image" content="http://localhost:1313/home/me.png">
  <meta name="twitter:title" content="ipc基础">
  <meta name="twitter:description" content="IPC 详细解释 IPC（Inter-Process Communication，进程间通信）是一个广泛的概念，指的是在操作系统中，不同进程之间交换数据和信号的机制。在多任务操作系统中，IPC 非常重要，因为它允许进程协同工作、共享资源或传递信息。">

  <meta itemprop="name" content="ipc基础">
  <meta itemprop="description" content="IPC 详细解释 IPC（Inter-Process Communication，进程间通信）是一个广泛的概念，指的是在操作系统中，不同进程之间交换数据和信号的机制。在多任务操作系统中，IPC 非常重要，因为它允许进程协同工作、共享资源或传递信息。">
  <meta itemprop="datePublished" content="2025-05-18T09:54:34+08:00">
  <meta itemprop="dateModified" content="2025-05-18T11:29:01+08:00">
  <meta itemprop="wordCount" content="2676">
  <meta itemprop="image" content="http://localhost:1313/home/me.png">
<link rel="apple-touch-icon" sizes="180x180" href="/favicon/favicon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png">
<link rel="manifest" href="/favicon/site.webmanifest">
<link rel="mask-icon" href="/favicon/safari-pinned-tab.svg" color="#5bbad5">
<link rel="shortcut icon" href="/favicon.ico">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="msapplication-config" content="/favicon/browserconfig.xml">
<meta name="theme-color" content="#ffffff"> 


<meta name="description" content="IPC 详细解释 IPC（Inter-Process Communication，进程间通信）是一个广泛的概念，指的是在操作系统中，不同进程之间交换数据和信号的机制。在多任务操作系统中，IPC 非常重要，因为它允许进程协同工作、共享资源或传递信息。
">
<meta name="keywords" content="AI, 机器学习, golang, kubernetes, 技术博客">
<meta name="author" content="高新">


<meta property="og:type" content="article">
<meta property="og:url" content="http://localhost:1313/learn_cs/react-electron/ipc/">
<meta property="og:title" content="ipc基础 | 高新 | AI平台开发工程师">
<meta property="og:description" content="IPC 详细解释 IPC（Inter-Process Communication，进程间通信）是一个广泛的概念，指的是在操作系统中，不同进程之间交换数据和信号的机制。在多任务操作系统中，IPC 非常重要，因为它允许进程协同工作、共享资源或传递信息。
">
<meta property="og:image" content="http://localhost:1313/home/me.png">


<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:url" content="http://localhost:1313/learn_cs/react-electron/ipc/">
<meta name="twitter:title" content="ipc基础 | 高新 | AI平台开发工程师">
<meta name="twitter:description" content="IPC 详细解释 IPC（Inter-Process Communication，进程间通信）是一个广泛的概念，指的是在操作系统中，不同进程之间交换数据和信号的机制。在多任务操作系统中，IPC 非常重要，因为它允许进程协同工作、共享资源或传递信息。
">
<meta name="twitter:image" content="http://localhost:1313/home/me.png">


<link rel="canonical" href="http://localhost:1313/learn_cs/react-electron/ipc/">


<link rel="stylesheet" href="/css/math.css">


<script>
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      displayMath: [['$$', '$$'], ['\\[', '\\]']],
      processEscapes: true,
      processEnvironments: true
    },
    svg: {
      fontCache: 'global'
    }
  };
</script>
<script id="MathJax-script" async src="/js/mathjax/tex-svg.js"></script> </head>
<body>

<div class="container"><header>
<h1>高新 | AI平台开发工程师</h1><a href="https://github.com/mlcore-engine/mlcore-engine" class="github"><i class="fab fa-github"></i></a>
<p class="description">AI平台开发工程师，专注于AI平台工程和Kubernetes云原生技术。拥有AI平台开发、GPU资源优化和AI服务部署经验</p>

</header>


<div class="content-container">
<main><h1>ipc基础</h1>
<h3 id="ipc-详细解释">IPC 详细解释</h3>
<p>IPC（Inter-Process Communication，进程间通信）是一个广泛的概念，指的是在操作系统中，不同进程之间交换数据和信号的机制。在多任务操作系统中，IPC 非常重要，因为它允许进程协同工作、共享资源或传递信息。</p>
<hr>
<h4 id="1-ipc-通信方式">1. IPC 通信方式</h4>
<p>在 Linux 系统中，IPC 提供了多种通信方式，每种方式适用于不同的场景。以下是常见的 IPC 机制：</p>
<ul>
<li>
<p><strong>管道（Pipes）</strong><br>
管道是一种单向数据流机制，允许一个进程的输出作为另一个进程的输入。管道分为两种：</p>
<ul>
<li><strong>匿名管道</strong>：用于相关进程（如父子进程）之间的通信，常用于 shell 中的数据重定向（例如 <code>ls | grep &quot;file&quot;</code>）。</li>
<li><strong>命名管道（FIFO）</strong>：通过文件系统中的特殊文件实现，适用于不相关进程之间的通信。</li>
</ul>
</li>
<li>
<p><strong>消息队列（Message Queues）</strong><br>
消息队列允许进程通过共享的队列发送和接收消息。发送进程将消息放入队列后可以继续执行，接收进程则在需要时读取消息。这种异步通信方式特别适合解耦发送者和接收者的执行。Linux 支持 System V 消息队列和 POSIX 消息队列两种实现。</p>
</li>
<li>
<p><strong>共享内存（Shared Memory）</strong><br>
共享内存允许多个进程访问同一块内存区域，是 IPC 中最快的方式，因为数据不需要在进程间复制，而是直接读写共享内存。不过，为了避免竞争条件，共享内存通常需要与同步机制（如信号量）配合使用。</p>
</li>
<li>
<p><strong>信号量（Semaphores）</strong><br>
信号量是一种同步和互斥工具，用于控制多个进程对共享资源的访问。信号量通过计数器机制工作，可以防止多个进程同时修改同一资源，常与共享内存结合使用。</p>
</li>
<li>
<p><strong>套接字（Sockets）</strong><br>
套接字主要用于网络通信，但也支持同一台机器上的进程间通信。它提供了一种灵活的方式，支持多种协议（如 TCP、UDP）和通信模式。套接字适用于需要跨进程甚至跨主机通信的场景。</p>
</li>
</ul>
<hr>
<h4 id="2-linux-中的-ipc-namespace-隔离">2. Linux 中的 IPC Namespace 隔离</h4>
<p>Linux 内核通过 Namespace 机制实现了资源隔离，IPC Namespace 是其中一种，专门用于隔离 IPC 资源。IPC Namespace 隔离的对象包括 System V IPC（消息队列、信号量、共享内存）和 POSIX 消息队列。</p>
<ul>
<li><strong>IPC Namespace 的隔离特性</strong>
<ul>
<li>每个 IPC Namespace 拥有独立的 IPC 资源集合，与其他 Namespace 互不干扰。</li>
<li>在一个 IPC Namespace 中创建的 IPC 资源（如消息队列）只能被该 Namespace 中的进程访问，其他 Namespace 中的进程无法感知或操作这些资源。</li>
<li>这种隔离增强了系统的安全性和稳定性，避免了进程间的意外冲突。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-ipc-的其他应用">3. IPC 的其他应用</h4>
<ul>
<li>
<p><strong>分布式系统</strong><br>
IPC 的概念可以扩展到网络层面，用于不同主机上的进程间通信。例如，远程过程调用（RPC）是一种常见的分布式 IPC 机制，允许一个进程调用另一台主机上的函数，类似本地调用。</p>
</li>
<li>
<p><strong>并发编程</strong><br>
在多线程或多进程的并发环境中，IPC 机制（如信号量、互斥锁）用于同步和协调执行顺序。例如，信号量可以确保多个进程按顺序访问共享资源，避免数据竞争。</p>
</li>
<li>
<p><strong>操作系统内核</strong><br>
操作系统内核内部也依赖 IPC 机制管理进程和资源。例如，Linux 内核通过信号传递（一种 IPC 方式）通知进程特定事件的发生，如进程终止或资源可用。</p>
</li>
<li>
<p><strong>软件架构</strong><br>
在软件设计中，IPC 支持模块化开发。将系统分解为多个独立进程或服务，通过 IPC 进行通信，可以提高系统的可维护性和可扩展性。这种设计在微服务架构中尤为常见，服务间通过 IPC（如消息队列或套接字）协作。</p>
</li>
</ul>
<hr>
<h2 id="electron-中的-ipc-通信">Electron 中的 IPC 通信</h2>
<p>在 Electron 应用中，进程间通信（IPC）是一个核心概念，主要通过 <code>ipcMain</code> 和 <code>ipcRenderer</code> 模块实现。</p>
<h3 id="1-ipc-通信的基本概念">1. IPC 通信的基本概念</h3>
<p>Electron 应用分为两个主要进程：</p>
<ul>
<li><strong>主进程</strong>：负责管理应用程序的生命周期、创建窗口、与操作系统交互，通常通过 <code>main.js</code> 文件运行。</li>
<li><strong>渲染进程</strong>：负责显示用户界面，通常是基于 HTML/CSS/JavaScript 的网页内容，每个窗口对应一个渲染进程。</li>
</ul>
<p>由于安全性和性能的考虑，主进程和渲染进程之间不能直接访问对方的资源或代码。因此，Electron 提供了 IPC 机制，通过 <code>ipcMain</code> 和 <code>ipcRenderer</code> 模块实现数据的传递和功能的调用。</p>
<ul>
<li><strong><code>ipcMain</code></strong>：运行在主进程中，用于监听渲染进程发送的消息或主动向渲染进程发送消息。</li>
<li><strong><code>ipcRenderer</code></strong>：运行在渲染进程中，用于向主进程发送消息或监听主进程发送的消息。</li>
</ul>
<h3 id="2-常用方法">2. 常用方法</h3>
<h4 id="21-ipcrenderer渲染进程">2.1 <code>ipcRenderer</code>（渲染进程）</h4>
<ul>
<li>
<p><strong><code>ipcRenderer.send(channel, ...args)</code></strong><br>
向主进程发送异步消息，<code>channel</code> 是消息的通道名称，<code>...args</code> 是附带的参数。</p>
</li>
<li>
<p><strong><code>ipcRenderer.on(channel, listener)</code></strong><br>
监听指定通道的消息，<code>listener</code> 是一个回调函数，接收主进程发送的数据。</p>
</li>
<li>
<p><strong><code>ipcRenderer.invoke(channel, ...args)</code></strong><br>
向主进程发送消息并返回一个 Promise，用于同步通信，等待主进程的处理结果。</p>
</li>
<li>
<p><strong><code>ipcRenderer.removeListener(channel, listener)</code></strong><br>
移除指定通道的监听器，避免内存泄漏。</p>
</li>
</ul>
<h4 id="22-ipcmain主进程">2.2 <code>ipcMain</code>（主进程）</h4>
<ul>
<li>
<p><strong><code>ipcMain.on(channel, listener)</code></strong><br>
监听渲染进程发送的异步消息，<code>listener</code> 是一个回调函数，接收事件对象和参数。</p>
</li>
<li>
<p><strong><code>ipcMain.handle(channel, handler)</code></strong><br>
处理渲染进程通过 <code>invoke</code> 发送的请求，<code>handler</code> 返回结果（可以是 Promise）。</p>
</li>
<li>
<p><strong><code>event.reply(channel, ...args)</code></strong><br>
在 <code>ipcMain.on</code> 的监听器中，向发送消息的渲染进程回复消息。</p>
</li>
<li>
<p><strong><code>BrowserWindow.webContents.send(channel, ...args)</code></strong><br>
主进程主动向某个窗口的渲染进程发送消息。</p>
</li>
</ul>
<h3 id="3-实际开发中的使用方式">3. 实际开发中的使用方式</h3>
<h4 id="31-异步通信send--on">3.1 异步通信：<code>send</code> + <code>on</code></h4>
<p><strong>场景</strong>：渲染进程通知主进程执行操作，但不需要等待返回结果。例如，点击按钮打开新窗口。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#75715e">// 渲染进程（renderer.js）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> { <span style="color:#a6e22e">ipcRenderer</span> } <span style="color:#f92672">=</span> <span style="color:#a6e22e">require</span>(<span style="color:#e6db74">&#39;electron&#39;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>document.<span style="color:#a6e22e">getElementById</span>(<span style="color:#e6db74">&#39;open-window&#39;</span>).<span style="color:#a6e22e">addEventListener</span>(<span style="color:#e6db74">&#39;click&#39;</span>, () =&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">ipcRenderer</span>.<span style="color:#a6e22e">send</span>(<span style="color:#e6db74">&#39;open-new-window&#39;</span>, <span style="color:#e6db74">&#39;some data&#39;</span>);
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 主进程（main.js）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> { <span style="color:#a6e22e">app</span>, <span style="color:#a6e22e">BrowserWindow</span>, <span style="color:#a6e22e">ipcMain</span> } <span style="color:#f92672">=</span> <span style="color:#a6e22e">require</span>(<span style="color:#e6db74">&#39;electron&#39;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">app</span>.<span style="color:#a6e22e">whenReady</span>().<span style="color:#a6e22e">then</span>(() =&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">mainWindow</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">BrowserWindow</span>({ <span style="color:#a6e22e">width</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">800</span>, <span style="color:#a6e22e">height</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">600</span> });
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">mainWindow</span>.<span style="color:#a6e22e">loadFile</span>(<span style="color:#e6db74">&#39;index.html&#39;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">ipcMain</span>.<span style="color:#a6e22e">on</span>(<span style="color:#e6db74">&#39;open-new-window&#39;</span>, (<span style="color:#a6e22e">event</span>, <span style="color:#a6e22e">arg</span>) =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">arg</span>); <span style="color:#75715e">// 输出：&#39;some data&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">newWindow</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">BrowserWindow</span>({ <span style="color:#a6e22e">width</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">400</span>, <span style="color:#a6e22e">height</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">300</span> });
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">newWindow</span>.<span style="color:#a6e22e">loadFile</span>(<span style="color:#e6db74">&#39;new-window.html&#39;</span>);
</span></span><span style="display:flex;"><span>  });
</span></span><span style="display:flex;"><span>});
</span></span></code></pre></div><h4 id="32-同步通信invoke--handle">3.2 同步通信：<code>invoke</code> + <code>handle</code></h4>
<p><strong>场景</strong>：渲染进程需要从主进程获取数据并等待结果。例如，读取文件内容。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#75715e">// 渲染进程（renderer.js）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> { <span style="color:#a6e22e">ipcRenderer</span> } <span style="color:#f92672">=</span> <span style="color:#a6e22e">require</span>(<span style="color:#e6db74">&#39;electron&#39;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">getFileContent</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">content</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> <span style="color:#a6e22e">ipcRenderer</span>.<span style="color:#a6e22e">invoke</span>(<span style="color:#e6db74">&#39;read-file&#39;</span>, <span style="color:#e6db74">&#39;path/to/file.txt&#39;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">content</span>);
</span></span><span style="display:flex;"><span>  } <span style="color:#66d9ef">catch</span> (<span style="color:#a6e22e">error</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">error</span>(<span style="color:#e6db74">&#39;Error reading file:&#39;</span>, <span style="color:#a6e22e">error</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 主进程（main.js）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> { <span style="color:#a6e22e">app</span>, <span style="color:#a6e22e">BrowserWindow</span>, <span style="color:#a6e22e">ipcMain</span> } <span style="color:#f92672">=</span> <span style="color:#a6e22e">require</span>(<span style="color:#e6db74">&#39;electron&#39;</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">fs</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">require</span>(<span style="color:#e6db74">&#39;fs&#39;</span>).<span style="color:#a6e22e">promises</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">app</span>.<span style="color:#a6e22e">whenReady</span>().<span style="color:#a6e22e">then</span>(() =&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">mainWindow</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">BrowserWindow</span>({ <span style="color:#a6e22e">width</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">800</span>, <span style="color:#a6e22e">height</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">600</span> });
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">mainWindow</span>.<span style="color:#a6e22e">loadFile</span>(<span style="color:#e6db74">&#39;index.html&#39;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">ipcMain</span>.<span style="color:#a6e22e">handle</span>(<span style="color:#e6db74">&#39;read-file&#39;</span>, <span style="color:#66d9ef">async</span> (<span style="color:#a6e22e">event</span>, <span style="color:#a6e22e">filePath</span>) =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">content</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> <span style="color:#a6e22e">fs</span>.<span style="color:#a6e22e">readFile</span>(<span style="color:#a6e22e">filePath</span>, <span style="color:#e6db74">&#39;utf-8&#39;</span>);
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">content</span>;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">catch</span> (<span style="color:#a6e22e">error</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">throw</span> <span style="color:#a6e22e">error</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  });
</span></span><span style="display:flex;"><span>});
</span></span></code></pre></div><h4 id="33-主进程向渲染进程发送消息">3.3 主进程向渲染进程发送消息</h4>
<p><strong>场景</strong>：主进程主动通知渲染进程更新 UI 或传递数据。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#75715e">// 主进程（main.js）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> { <span style="color:#a6e22e">app</span>, <span style="color:#a6e22e">BrowserWindow</span> } <span style="color:#f92672">=</span> <span style="color:#a6e22e">require</span>(<span style="color:#e6db74">&#39;electron&#39;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">mainWindow</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">app</span>.<span style="color:#a6e22e">whenReady</span>().<span style="color:#a6e22e">then</span>(() =&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">mainWindow</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">BrowserWindow</span>({ <span style="color:#a6e22e">width</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">800</span>, <span style="color:#a6e22e">height</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">600</span> });
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">mainWindow</span>.<span style="color:#a6e22e">loadFile</span>(<span style="color:#e6db74">&#39;index.html&#39;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">setTimeout</span>(() =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mainWindow</span>.<span style="color:#a6e22e">webContents</span>.<span style="color:#a6e22e">send</span>(<span style="color:#e6db74">&#39;show-notification&#39;</span>, <span style="color:#e6db74">&#39;Hello from main!&#39;</span>);
</span></span><span style="display:flex;"><span>  }, <span style="color:#ae81ff">5000</span>);
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 渲染进程（renderer.js）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> { <span style="color:#a6e22e">ipcRenderer</span> } <span style="color:#f92672">=</span> <span style="color:#a6e22e">require</span>(<span style="color:#e6db74">&#39;electron&#39;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">ipcRenderer</span>.<span style="color:#a6e22e">on</span>(<span style="color:#e6db74">&#39;show-notification&#39;</span>, (<span style="color:#a6e22e">event</span>, <span style="color:#a6e22e">message</span>) =&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">alert</span>(<span style="color:#a6e22e">message</span>); <span style="color:#75715e">// 显示弹窗：&#39;Hello from main!&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>});
</span></span></code></pre></div><h3 id="4-最佳实践">4. 最佳实践</h3>
<ol>
<li>
<p><strong>优先使用 <code>invoke</code> 和 <code>handle</code></strong>：</p>
<ul>
<li>同步通信更清晰</li>
<li>支持错误处理</li>
<li>适合需要返回值的场景</li>
</ul>
</li>
<li>
<p><strong>避免在渲染进程直接调用 Node.js API</strong>：</p>
<ul>
<li>将文件操作、系统调用等放在主进程</li>
<li>通过 IPC 调用</li>
<li>保持渲染进程轻量和安全</li>
</ul>
</li>
<li>
<p><strong>通道命名规范</strong>：</p>
<ul>
<li>使用有意义的名称（如 <code>app:open-file</code>、<code>window:resize</code>）</li>
<li>避免命名冲突</li>
</ul>
</li>
<li>
<p><strong>错误处理</strong>：</p>
<ul>
<li>在 <code>handle</code> 中抛出错误</li>
<li>在渲染进程中捕获 Promise 的 reject</li>
</ul>
</li>
<li>
<p><strong>安全性</strong>：</p>
<ul>
<li>如果启用了 <code>contextIsolation</code></li>
<li>通过 <code>contextBridge</code> 暴露安全的 IPC 接口</li>
<li>避免直接使用 <code>ipcRenderer</code></li>
</ul>
</li>
</ol>
<h3 id="5-总结">5. 总结</h3>
<ul>
<li><strong>异步通信</strong>：<code>ipcRenderer.send</code> + <code>ipcMain.on</code>，适合通知类操作</li>
<li><strong>同步通信</strong>：<code>ipcRenderer.invoke</code> + <code>ipcMain.handle</code>，适合请求数据</li>
<li><strong>主进程主动通信</strong>：<code>BrowserWindow.webContents.send</code> + <code>ipcRenderer.on</code>，适合主进程通知渲染进程</li>
</ul>
<div class="edit-meta"> <br></div><nav class="pagination"><a class="nav nav-prev" href="http://localhost:1313/learn_cs/react-electron/ts-foundation/" title="ts-foundation"><i class="fas fa-arrow-left" aria-hidden="true"></i>&nbsp;Prev - ts-foundation</a>
<a class="nav nav-next" href="http://localhost:1313/algorithm/" title="算法题">Next - 算法题 <i class="fas fa-arrow-right" aria-hidden="true"></i></a>
</nav><footer> </footer>
</main>
<div class="sidebar">

<nav class="slide-menu">
<ul>
<li class=""><a href="http://localhost:1313/">about me</a></li>

<li class="parent has-sub-menu"><a href="http://localhost:1313/learn_cs/">cs基础<span class="mark opened">-</span></a>
  
<ul class="sub-menu">
<li class=""><a href="http://localhost:1313/learn_cs/react-electron/ts-foundation/">ts-foundation</a></li>
<li class="active"><a href="http://localhost:1313/learn_cs/react-electron/ipc/">ipc基础</a></li>
</ul>
  
</li>

<li class=" has-sub-menu"><a href="http://localhost:1313/algorithm/">算法题<span class="mark closed">+</span></a>
  
<ul class="sub-menu">
<li class=""><a href="http://localhost:1313/algorithm/double_point/">双指针</a></li>
<li class=""><a href="http://localhost:1313/algorithm/strings/">string类题目</a></li>
<li class=""><a href="http://localhost:1313/algorithm/dynamic-programmnig/">动态规划问题</a></li>
</ul>
  
</li>

<li class=" has-sub-menu"><a href="http://localhost:1313/math_foundation/">ML中的数学<span class="mark closed">+</span></a>
  
<ul class="sub-menu">
<li class=""><a href="http://localhost:1313/math_foundation/information/">信息量</a></li>
<li class=""><a href="http://localhost:1313/math_foundation/likelihood_entropy/">似然函数_交叉熵</a></li>
<li class=""><a href="http://localhost:1313/math_foundation/kl_dpo/">Kl散度与dpo算法</a></li>
</ul>
  
</li>

<li class=" has-sub-menu"><a href="http://localhost:1313/transformer/">ML基础<span class="mark closed">+</span></a>
  
<ul class="sub-menu">
<li class=""><a href="http://localhost:1313/transformer/do_sample_para/">Do_sample_para</a></li>
<li class=""><a href="http://localhost:1313/transformer/nn_begin/">Nn Begin</a></li>
<li class=""><a href="http://localhost:1313/transformer/entropy/">Entropy</a></li>
</ul>
  
</li>

<li class=" has-sub-menu"><a href="http://localhost:1313/kubernetes/">kubernetes<span class="mark closed">+</span></a>
  
<ul class="sub-menu">
<li class=""><a href="http://localhost:1313/kubernetes/installation/">Installation</a></li>
</ul>
  
</li>

<li class=""><a href="http://localhost:1313/learn_english/">英语学习</a>
  
</li>

<li class=" has-sub-menu"><a href="http://localhost:1313/golang/">golang<span class="mark closed">+</span></a>
  
<ul class="sub-menu">
<li class=""><a href="http://localhost:1313/golang/matrix-golang/">matrix-golang</a></li>
<li class=""><a href="http://localhost:1313/golang/sort/">sort包用法</a></li>
<li class=""><a href="http://localhost:1313/golang/foundation/">Go 语言基础知识</a></li>
<li class=""><a href="http://localhost:1313/golang/base/">Base</a></li>
</ul>
  
</li>

<li class=" has-sub-menu"><a href="http://localhost:1313/linux_foundation/">Linux基础<span class="mark closed">+</span></a>
  
<ul class="sub-menu">
<li class=""><a href="http://localhost:1313/linux_foundation/linux-commands/">50个常用Linux命令</a></li>
<li class=""><a href="http://localhost:1313/linux_foundation/cs_foundation/">计算机基础知识</a></li>
<li class=""><a href="http://localhost:1313/linux_foundation/linux-common/">Linux Common</a></li>
</ul>
  
</li>

<li class=" has-sub-menu"><a href="http://localhost:1313/exercise/">workout<span class="mark closed">+</span></a>
  
<ul class="sub-menu">
<li class=""><a href="http://localhost:1313/exercise/workout/">Workout</a></li>
</ul>
  
</li>

<li class=" has-sub-menu"><a href="http://localhost:1313/others/">others<span class="mark closed">+</span></a>
  
<ul class="sub-menu">
<li class=""><a href="http://localhost:1313/others/create-hugo-gitpage/">使用 Hugo 和 GitHub Pages 创建个人网站</a></li>
</ul>
  
</li>
</ul>
</nav>

 
<div class="sidebar-footer"></div>
</div>

</div><a href="#" id="backtothetop-fixed" class="backtothetop"
 data-backtothetop-duration="600"
 data-backtothetop-easing="easeOutQuart"
 data-backtothetop-fixed-fadeIn="1000"
 data-backtothetop-fixed-fadeOut="1000"
 data-backtothetop-fixed-bottom="10"
 data-backtothetop-fixed-right="20">
<span class="fa-layers fa-fw">
<i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i>
</span></a>
</div>
</body>
</html>
