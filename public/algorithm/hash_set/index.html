<!DOCTYPE html>
<html lang="zh-cn">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<title>哈希表相关题目 - 高新 | AI平台开发工程师</title>
<meta name="description" content="AI平台开发工程师，专注于AI平台工程和Kubernetes云原生技术。拥有AI平台开发、GPU资源优化和AI服务部署经验">
<meta name="generator" content="Hugo 0.145.0">
<link href="http://localhost:1313//index.xml" rel="alternate" type="application/rss+xml">
<link rel="canonical" href="http://localhost:1313/algorithm/hash_set/">
<link rel="stylesheet" href="http://localhost:1313/css/theme.min.css">
<link rel="stylesheet" href="http://localhost:1313/css/chroma.min.css">
<script defer src="http://localhost:1313//js/fontawesome6/all.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js" integrity="sha256-H3cjtrm/ztDeuhCN9I4yh4iN2Ybx/y1RM7rMmAesA0k=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js" integrity="sha256-4XodgW4TwIJuDtf+v6vDJ39FVxI0veC/kSCCmnFp7ck=" crossorigin="anonymous"></script>
<script src="http://localhost:1313/js/bundle.js"></script><style>
 
@media screen and (min-width: 480px) {
  .sidebar {
    flex: 0 0 20% !important;
    max-width: 20% !important;
  }
  
  main {
    flex: 0 0 80% !important;
    max-width: 80% !important;
  }
}

 
body {
  background-color: #f8f5e6 !important;  
  font-family: 'KaiTi', 'STKaiti', '楷体', '楷体_GB2312', 'SimKai', '华文楷体', Kai, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif !important;  
  font-size: 20px !important;  
  line-height: 1.8 !important;  
}

 
.container, .content-container, main {
  background-color: #f8f5e6 !important;
}

 
.sidebar {
  background-color: inherit;
  font-size: 16px !important;  
}

 
h1, h2, h3, h4, h5, h6 {
  font-family: 'KaiTi', 'STKaiti', '楷体', '楷体_GB2312', 'SimKai', '华文楷体', Kai, 'Noto Serif', Georgia, serif !important;
  font-weight: 600 !important;
  line-height: 1.5 !important;
}

 
h1 {
  font-size: 2.4em !important;
}

h2 {
  font-size: 2em !important;
}

h3 {
  font-size: 1.7em !important;
}

h4 {
  font-size: 1.5em !important;
}

h5 {
  font-size: 1.3em !important;
}

h6 {
  font-size: 1.2em !important;
}

 
p {
  font-size: 20px !important;
  margin-bottom: 1.2em !important;
}

 
li {
  font-size: 20px !important;
  margin-bottom: 0.5em !important;
}

 
article, .content, .post-content, main p, main li, main td, main th, blockquote, .markdown {
  font-size: 20px !important;
}

 
pre, code {
  font-family: 'JetBrains Mono', Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace !important;
  font-size: 1.1em !important;  
}

 
a {
  color: #0066cc !important;
  text-decoration: none !important;
}

a:hover {
  text-decoration: underline !important;
}

 
table {
  font-size: 20px !important;
}
</style> <meta property="og:url" content="http://localhost:1313/algorithm/hash_set/">
  <meta property="og:site_name" content="高新 | AI平台开发工程师">
  <meta property="og:title" content="哈希表相关题目">
  <meta property="og:description" content="哈希表一般解题方法 1. 频率计数法（Frequency Counting） 适用问题: Ransom Note、Valid Anagram、Group Anagrams
方法: 使用哈希表统计字符或元素的出现频率。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="algorithm">
    <meta property="article:published_time" content="2025-05-30T09:14:55+08:00">
    <meta property="article:modified_time" content="2025-05-31T22:50:26+08:00">
    <meta property="og:image" content="http://localhost:1313/home/me.png">

  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:image" content="http://localhost:1313/home/me.png">
  <meta name="twitter:title" content="哈希表相关题目">
  <meta name="twitter:description" content="哈希表一般解题方法 1. 频率计数法（Frequency Counting） 适用问题: Ransom Note、Valid Anagram、Group Anagrams
方法: 使用哈希表统计字符或元素的出现频率。">

  <meta itemprop="name" content="哈希表相关题目">
  <meta itemprop="description" content="哈希表一般解题方法 1. 频率计数法（Frequency Counting） 适用问题: Ransom Note、Valid Anagram、Group Anagrams
方法: 使用哈希表统计字符或元素的出现频率。">
  <meta itemprop="datePublished" content="2025-05-30T09:14:55+08:00">
  <meta itemprop="dateModified" content="2025-05-31T22:50:26+08:00">
  <meta itemprop="wordCount" content="2508">
  <meta itemprop="image" content="http://localhost:1313/home/me.png">
<link rel="apple-touch-icon" sizes="180x180" href="/favicon/favicon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png">
<link rel="manifest" href="/favicon/site.webmanifest">
<link rel="mask-icon" href="/favicon/safari-pinned-tab.svg" color="#5bbad5">
<link rel="shortcut icon" href="/favicon.ico">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="msapplication-config" content="/favicon/browserconfig.xml">
<meta name="theme-color" content="#ffffff"> 


<meta name="description" content="哈希表一般解题方法 1. 频率计数法（Frequency Counting） 适用问题: Ransom Note、Valid Anagram、Group Anagrams
方法: 使用哈希表统计字符或元素的出现频率。
">
<meta name="keywords" content="AI, 机器学习, golang, kubernetes, 技术博客">
<meta name="author" content="高新">


<meta property="og:type" content="article">
<meta property="og:url" content="http://localhost:1313/algorithm/hash_set/">
<meta property="og:title" content="哈希表相关题目 | 高新 | AI平台开发工程师">
<meta property="og:description" content="哈希表一般解题方法 1. 频率计数法（Frequency Counting） 适用问题: Ransom Note、Valid Anagram、Group Anagrams
方法: 使用哈希表统计字符或元素的出现频率。
">
<meta property="og:image" content="http://localhost:1313/home/me.png">


<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:url" content="http://localhost:1313/algorithm/hash_set/">
<meta name="twitter:title" content="哈希表相关题目 | 高新 | AI平台开发工程师">
<meta name="twitter:description" content="哈希表一般解题方法 1. 频率计数法（Frequency Counting） 适用问题: Ransom Note、Valid Anagram、Group Anagrams
方法: 使用哈希表统计字符或元素的出现频率。
">
<meta name="twitter:image" content="http://localhost:1313/home/me.png">


<link rel="canonical" href="http://localhost:1313/algorithm/hash_set/">


<link rel="stylesheet" href="/css/math.css">


<script>
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      displayMath: [['$$', '$$'], ['\\[', '\\]']],
      processEscapes: true,
      processEnvironments: true
    },
    svg: {
      fontCache: 'global'
    }
  };
</script>
<script id="MathJax-script" async src="/js/mathjax/tex-svg.js"></script> </head>
<body>

<div class="container"><header>
<h1>高新 | AI平台开发工程师</h1><a href="https://github.com/mlcore-engine/mlcore-engine" class="github"><i class="fab fa-github"></i></a>
<p class="description">AI平台开发工程师，专注于AI平台工程和Kubernetes云原生技术。拥有AI平台开发、GPU资源优化和AI服务部署经验</p>

</header>


<div class="content-container">
<main><h1>哈希表相关题目</h1>
<h3 id="哈希表一般解题方法">哈希表一般解题方法</h3>
<h4 id="1-频率计数法frequency-counting">1. 频率计数法（Frequency Counting）</h4>
<p><strong>适用问题</strong>: Ransom Note、Valid Anagram、Group Anagrams<br>
<strong>方法</strong>: 使用哈希表统计字符或元素的出现频率。</p>
<ul>
<li>对于 Ransom Note，检查一个字符串是否能由另一个字符串的字符构成，通过统计频率并逐一扣减。
<ul>
<li>例子:</li>
<li>ransomNote = &ldquo;aa&rdquo;, magazine = &ldquo;aab&rdquo; → 可以，因为 magazine 有 2 个 &lsquo;a&rsquo; 和 1 个 &lsquo;b&rsquo;，足够拼出 &ldquo;aa&rdquo;。</li>
<li>ransomNote = &ldquo;aa&rdquo;, magazine = &ldquo;ab&rdquo; → 不行，因为 magazine 只有 1 个 &lsquo;a&rsquo;，不够用。</li>
</ul>
</li>
<li>对于 Valid Anagram，比较两个字符串的字符频率是否完全相同。
<ul>
<li>例子:</li>
<li>s = &ldquo;listen&rdquo;, t = &ldquo;silent&rdquo; → 是，因为两者的字符（l, i, s, t, e, n）次数相同。</li>
<li>s = &ldquo;hello&rdquo;, t = &ldquo;world&rdquo; → 不是，因为字符种类和次数都不一样。</li>
</ul>
</li>
<li>对于 Group Anagrams，将频率特征（或排序后的字符串）作为键，将相同频率的字符串分组。
<ul>
<li>例子:</li>
<li>输入: [&ldquo;eat&rdquo;, &ldquo;tea&rdquo;, &ldquo;tan&rdquo;, &ldquo;ate&rdquo;, &ldquo;nat&rdquo;, &ldquo;bat&rdquo;]</li>
<li>输出: [[&ldquo;eat&rdquo;, &ldquo;tea&rdquo;, &ldquo;ate&rdquo;], [&ldquo;tan&rdquo;, &ldquo;nat&rdquo;], [&ldquo;bat&rdquo;]]</li>
<li>解释: &ldquo;eat&rdquo;、&ldquo;tea&rdquo;、&ldquo;ate&rdquo; 是异位词，&ldquo;tan&rdquo;、&ldquo;nat&rdquo; 是异位词，&ldquo;bat&rdquo; 单独一组。</li>
</ul>
</li>
</ul>
<p><strong>关键点</strong>:  c</p>
<ul>
<li>
<p>使用 map 统计频率。</p>
</li>
<li>
<p>考虑输入是否仅限于 ASCII（可用数组代替 map）或包含 Unicode（用 map 更通用）。</p>
</li>
<li>
<p><strong>频率计数法 Valid Anagram</strong></p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">isAnagram</span>(<span style="color:#a6e22e">s</span>, <span style="color:#a6e22e">t</span> <span style="color:#66d9ef">string</span>) <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">s</span>) <span style="color:#f92672">!=</span> len(<span style="color:#a6e22e">t</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">count</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">rune</span>]<span style="color:#66d9ef">int</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">char</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">s</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">count</span>[<span style="color:#a6e22e">char</span>]<span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">char</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">t</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">count</span>[<span style="color:#a6e22e">char</span>]<span style="color:#f92672">--</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">count</span>[<span style="color:#a6e22e">char</span>] &lt; <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>时间复杂度</strong>: O(n)，n 为字符串长度。<br>
<strong>空间复杂度</strong>: O(k)，k 为字符集大小。</p>
<hr>
<h4 id="2-映射与模式法mapping-and-patterns">2. 映射与模式法（Mapping and Patterns）</h4>
<p><strong>适用问题</strong>: Isomorphic Strings、Word Pattern<br>
<strong>方法</strong>: 使用哈希表记录字符或单词之间的映射关系，确保映射一致性。</p>
<ul>
<li>Isomorphic Strings 检查两个字符串是否可以通过某种一致的字符映射相互转换。
<ul>
<li>例子:</li>
<li>s = &ldquo;egg&rdquo;, t = &ldquo;add&rdquo; → 是同构的。</li>
<li>映射：e → a, g → d，每个 e 都对应 a，每个 g 都对应 d，映射一致。</li>
<li>s = &ldquo;foo&rdquo;, t = &ldquo;bar&rdquo; → 不是同构的。</li>
<li>映射：f → b, o → a, 但第二个 o 需要映射到 r，不一致。</li>
<li>s = &ldquo;paper&rdquo;, t = &ldquo;title&rdquo; → 是同构的。</li>
<li>映射：p → t, a → i, p → t, e → l, r → e，映射一致。</li>
</ul>
</li>
<li>Word Pattern 检查字符串中的单词序列是否与给定的模式一致。
<ul>
<li>例子:</li>
<li>pattern = &ldquo;abba&rdquo;, s = &ldquo;dog cat cat dog&rdquo; → 是。</li>
<li>映射：a → dog, b → cat，模式一致。</li>
<li>pattern = &ldquo;abba&rdquo;, s = &ldquo;dog cat cat fish&rdquo; → 不是。</li>
<li>映射：a → dog, b → cat，但最后一个 a 应为 dog，却遇到 fish，不一致。</li>
<li>pattern = &ldquo;aaaa&rdquo;, s = &ldquo;dog dog dog dog&rdquo; → 是。</li>
<li>映射：a → dog，一致。</li>
<li>pattern = &ldquo;abba&rdquo;, s = &ldquo;dog dog dog dog&rdquo; → 不是。</li>
<li>映射：a → dog, b → dog，但 a 和 b 不能映射到同一个单词。</li>
</ul>
</li>
<li>通常需要两个 map，确保双向映射唯一。</li>
</ul>
<p><strong>关键点</strong>:</p>
<ul>
<li>双向检查映射，避免一对多或多对一的情况。</li>
</ul>
<h3 id="golang-示例代码">GoLang 示例代码</h3>
<p>以下是每类方法的 GoLang 实现，帮助你理解和记忆。</p>
<ul>
<li><strong>映射与模式法: Isomorphic Strings</strong></li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">isIsomorphic</span>(<span style="color:#a6e22e">s</span>, <span style="color:#a6e22e">t</span> <span style="color:#66d9ef">string</span>) <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">s</span>) <span style="color:#f92672">!=</span> len(<span style="color:#a6e22e">t</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mapST</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">byte</span>]<span style="color:#66d9ef">byte</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mapTS</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">byte</span>]<span style="color:#66d9ef">byte</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; len(<span style="color:#a6e22e">s</span>); <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">charS</span>, <span style="color:#a6e22e">charT</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">s</span>[<span style="color:#a6e22e">i</span>], <span style="color:#a6e22e">t</span>[<span style="color:#a6e22e">i</span>]
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">val</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">mapST</span>[<span style="color:#a6e22e">charS</span>]; <span style="color:#a6e22e">ok</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">val</span> <span style="color:#f92672">!=</span> <span style="color:#a6e22e">charT</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">mapST</span>[<span style="color:#a6e22e">charS</span>] = <span style="color:#a6e22e">charT</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">val</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">mapTS</span>[<span style="color:#a6e22e">charT</span>]; <span style="color:#a6e22e">ok</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">val</span> <span style="color:#f92672">!=</span> <span style="color:#a6e22e">charS</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">mapTS</span>[<span style="color:#a6e22e">charT</span>] = <span style="color:#a6e22e">charS</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>时间复杂度</strong>: O(n)，n 为字符串长度。<br>
<strong>空间复杂度</strong>: O(k)，k 为字符集大小。</p>
<hr>
<h4 id="3-查找配对或重复法finding-pairs-or-duplicates">3. 查找配对或重复法（Finding Pairs or Duplicates）</h4>
<p><strong>适用问题</strong>: Two Sum、Contains Duplicate II<br>
<strong>方法</strong>: 使用哈希表记录已见过的元素及其位置或属性。</p>
<ul>
<li>Two Sum 在数组中找两个和为目标值的数，用 map 存储每个数的补数。
<ul>
<li>例子:</li>
<li>输入: nums = [2, 7, 11, 15], target = 9</li>
<li>输出: [0, 1] 解释: nums[0] + nums[1] = 2 + 7 = 9。</li>
<li>输入: nums = [3, 2, 4], target = 6</li>
<li>输出: [1, 2] 解释: nums[1] + nums[2] = 2 + 4 = 6。</li>
<li>输入: nums = [3, 3], target = 6</li>
<li>输出: [0, 1] 解释: nums[0] + nums[1] = 3 + 3 = 6。</li>
</ul>
</li>
<li>Contains Duplicate II 检查数组中是否存在距离不超过 k 的重复元素，可用滑动窗口结合 map 或 set。 给你一个整数数组 nums 和一个整数 k，判断数组中是否存在两个不同的下标 i 和 j，使得 nums[i] == nums[j] 并且 |i - j| &lt;= k（即下标差不超过 k）。如果存在，返回 true；否则返回 false。
<ul>
<li>例子:</li>
<li>输入: nums = [1, 2, 3, 1], k = 3</li>
<li>输出: true</li>
<li>解释: nums[0] = nums[3] = 1，且 |0 - 3| = 3 &lt;= k。</li>
<li>输入: nums = [1, 0, 1, 1], k = 1</li>
<li>输出: true</li>
<li>解释: nums[2] = nums[3] = 1，且 |2 - 3| = 1 &lt;= k。</li>
<li>输入: nums = [1, 2, 3, 1, 2, 3], k = 2</li>
<li>输出: false</li>
<li>解释: 虽然有重复元素 1，但它们的下标差 |0 - 3| = 3 &gt; k。</li>
</ul>
</li>
</ul>
<p><strong>关键点</strong>:</p>
<ul>
<li>
<p>对于范围限制问题（如 k），考虑滑动窗口优化空间。</p>
</li>
<li>
<p><strong>查找配对法：Two Sum</strong></p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">twoSum</span>(<span style="color:#a6e22e">nums</span> []<span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">target</span> <span style="color:#66d9ef">int</span>) []<span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">numMap</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">int</span>]<span style="color:#66d9ef">int</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">num</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">nums</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">complement</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">target</span> <span style="color:#f92672">-</span> <span style="color:#a6e22e">num</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">idx</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">numMap</span>[<span style="color:#a6e22e">complement</span>]; <span style="color:#a6e22e">ok</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> []<span style="color:#66d9ef">int</span>{<span style="color:#a6e22e">idx</span>, <span style="color:#a6e22e">i</span>}
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">numMap</span>[<span style="color:#a6e22e">num</span>] = <span style="color:#a6e22e">i</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>时间复杂度</strong>: O(n)，n 为数组长度。<br>
<strong>空间复杂度</strong>: O(n)。</p>
<hr>
<h4 id="4-循环检测法cycle-detection">4. 循环检测法（Cycle Detection）</h4>
<p><strong>适用问题</strong>: Happy Number<br>
<strong>方法</strong>: 使用集合记录出现过的状态，检测是否进入循环。</p>
<ul>
<li>
<p>Happy Number 通过不断计算各位数字平方和，判断是否能达到 1，若出现重复则有循环。
Input: n = 19
Output: true
Explanation:
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1</p>
</li>
<li>
<p><strong>循环检测法：Happy Number</strong></p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">isHappy</span>(<span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">seen</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">int</span>]<span style="color:#66d9ef">struct</span>{})
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">n</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">seen</span>[<span style="color:#a6e22e">n</span>] <span style="color:#f92672">==</span> <span style="color:#66d9ef">struct</span>{}{} {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">seen</span>[<span style="color:#a6e22e">n</span>] = <span style="color:#66d9ef">struct</span>{}{}
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">n</span> = <span style="color:#a6e22e">getNext</span>(<span style="color:#a6e22e">n</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">n</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">getNext</span>(<span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">sum</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">n</span> &gt; <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">digit</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">n</span> <span style="color:#f92672">%</span> <span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">sum</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">digit</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">digit</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">n</span> <span style="color:#f92672">/=</span> <span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">sum</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>时间复杂度</strong>: O(log n) 或 O(1)，取决于循环长度。<br>
<strong>空间复杂度</strong>: O(log n) 或 O(1)。</p>
<p><strong>关键点</strong>:</p>
<ul>
<li>在 Go 中用 <code>map[类型]struct{}</code> 模拟集合。</li>
</ul>
<hr>
<h4 id="5-序列检测法sequence-detection">5. 序列检测法（Sequence Detection）</h4>
<p><strong>适用问题</strong>: Longest Consecutive Sequence</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>    Example 1:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        Input: nums <span style="color:#f92672">=</span> <span style="color:#f92672">[</span>100,4,200,1,3,2<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>        Output: <span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span>    Explanation: The longest consecutive elements sequence is <span style="color:#f92672">[</span>1, 2, 3, 4<span style="color:#f92672">]</span>. Therefore its length is 4.
</span></span><span style="display:flex;"><span>    Example 2:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        Input: nums <span style="color:#f92672">=</span> <span style="color:#f92672">[</span>0,3,7,2,5,8,4,6,0,1<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>        Output: <span style="color:#ae81ff">9</span>
</span></span><span style="display:flex;"><span>    Example 3:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        Input: nums <span style="color:#f92672">=</span> <span style="color:#f92672">[</span>1,0,1,2<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>        Output: <span style="color:#ae81ff">3</span>
</span></span></code></pre></div><p><strong>方法</strong>: 使用集合存储所有元素，检查每个可能的序列起点，计算最长连续序列。</p>
<ul>
<li>
<p>只对没有前驱（num-1 不存在）的数字开始检查序列，避免重复计算。</p>
</li>
<li>
<p><strong>序列检测法：Longest Consecutive Sequence</strong></p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">longestConsecutive</span>(<span style="color:#a6e22e">nums</span> []<span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">numSet</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">int</span>]<span style="color:#66d9ef">bool</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">maxLen</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">num</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">nums</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">numSet</span>[<span style="color:#a6e22e">num</span>] = <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">num</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">numSet</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">numSet</span>[<span style="color:#a6e22e">num</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">currentNum</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">num</span>
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">currentLen</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">numSet</span>[<span style="color:#a6e22e">currentNum</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>] {
</span></span><span style="display:flex;"><span>                    <span style="color:#a6e22e">currentNum</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#a6e22e">currentLen</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">maxLen</span> = max(<span style="color:#a6e22e">currentLen</span>, <span style="color:#a6e22e">maxLen</span>)
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">maxLen</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>时间复杂度</strong>: O(n)，n 为数组长度。<br>
<strong>空间复杂度</strong>: O(n)。
<strong>关键点</strong>:</p>
<ul>
<li>优化时间复杂度到 O(n)，每个元素只访问一次。</li>
</ul>
<hr>
<h3 id="解题步骤">解题步骤</h3>
<ol>
<li>
<p><strong>识别问题模式</strong></p>
<ul>
<li>看到字符频率或相同性检查 → 频率计数法。</li>
<li>看到映射或模式匹配 → 映射与模式法。</li>
<li>看到找配对或重复 → 查找配对法。</li>
<li>看到循环或重复计算 → 循环检测法。</li>
<li>看到连续性或序列 → 序列检测法。</li>
</ul>
</li>
<li>
<p><strong>熟练使用 GoLang 的 map</strong></p>
<ul>
<li><code>make(map[类型]类型)</code> 创建哈希表。</li>
<li><code>map[类型]struct{}</code> 模拟集合。</li>
<li>通过 <code>val, ok := map[key]</code> 检查键是否存在。</li>
</ul>
</li>
<li>
<p><strong>分析时间与空间复杂度</strong></p>
<ul>
<li>哈希表方法通常将时间复杂度从 O(n²) 或 O(n log n) 优化到 O(n)。</li>
<li>空间复杂度通常为 O(n) 或 O(k)，k 为有限字符集大小。</li>
</ul>
</li>
</ol>
<hr>
<div class="edit-meta"> <br></div><nav class="pagination"><a class="nav nav-prev" href="http://localhost:1313/algorithm/stock_dp/" title="股票交易动态规划总结"><i class="fas fa-arrow-left" aria-hidden="true"></i>&nbsp;Prev - 股票交易动态规划总结</a>
<a class="nav nav-next" href="http://localhost:1313/algorithm/double_point/" title="双指针">Next - 双指针 <i class="fas fa-arrow-right" aria-hidden="true"></i></a>
</nav><footer> </footer>
</main>
<div class="sidebar">

<nav class="slide-menu">
<ul>
<li class=""><a href="http://localhost:1313/">about me</a></li>

<li class=" has-sub-menu"><a href="http://localhost:1313/learn_cs/">cs基础<span class="mark closed">+</span></a>
  
<ul class="sub-menu">
<li class=""><a href="http://localhost:1313/learn_cs/git-crash-course/">git-crash-course</a></li>
<li class=""><a href="http://localhost:1313/learn_cs/react-electron/ts-foundation/">ts-foundation</a></li>
<li class=""><a href="http://localhost:1313/learn_cs/react-electron/ipc/">ipc基础</a></li>
</ul>
  
</li>

<li class="parent has-sub-menu"><a href="http://localhost:1313/algorithm/">算法题<span class="mark opened">-</span></a>
  
<ul class="sub-menu">
<li class=""><a href="http://localhost:1313/algorithm/stock_dp/">股票交易动态规划总结</a></li>
<li class="active"><a href="http://localhost:1313/algorithm/hash_set/">哈希表相关题目</a></li>
<li class=""><a href="http://localhost:1313/algorithm/double_point/">双指针</a></li>
<li class=""><a href="http://localhost:1313/algorithm/strings/">string类题目</a></li>
<li class=""><a href="http://localhost:1313/algorithm/dynamic-programmnig/">动态规划问题</a></li>
</ul>
  
</li>

<li class=" has-sub-menu"><a href="http://localhost:1313/math_foundation/">ML中的数学<span class="mark closed">+</span></a>
  
<ul class="sub-menu">
<li class=""><a href="http://localhost:1313/math_foundation/information/">信息量</a></li>
<li class=""><a href="http://localhost:1313/math_foundation/likelihood_entropy/">似然函数_交叉熵</a></li>
<li class=""><a href="http://localhost:1313/math_foundation/kl_dpo/">Kl散度与dpo算法</a></li>
</ul>
  
</li>

<li class=" has-sub-menu"><a href="http://localhost:1313/transformer/">ML基础<span class="mark closed">+</span></a>
  
<ul class="sub-menu">
<li class=""><a href="http://localhost:1313/transformer/quantization2/">模型量化基础</a></li>
<li class=""><a href="http://localhost:1313/transformer/quantization/">模型量化基础代码版</a></li>
<li class=""><a href="http://localhost:1313/transformer/do_sample_para/">Do_sample_para</a></li>
<li class=""><a href="http://localhost:1313/transformer/nn_begin/">Nn Begin</a></li>
<li class=""><a href="http://localhost:1313/transformer/entropy/">Entropy</a></li>
</ul>
  
</li>

<li class=" has-sub-menu"><a href="http://localhost:1313/kubernetes/">kubernetes<span class="mark closed">+</span></a>
  
<ul class="sub-menu">
<li class=""><a href="http://localhost:1313/kubernetes/installation/">Installation</a></li>
</ul>
  
</li>

<li class=""><a href="http://localhost:1313/learn_english/">英语学习</a>
  
</li>

<li class=" has-sub-menu"><a href="http://localhost:1313/golang/">golang<span class="mark closed">+</span></a>
  
<ul class="sub-menu">
<li class=""><a href="http://localhost:1313/golang/byte-character/">字符编码基础知识详解</a></li>
<li class=""><a href="http://localhost:1313/golang/matrix-golang/">matrix-golang</a></li>
<li class=""><a href="http://localhost:1313/golang/sort/">sort包用法</a></li>
<li class=""><a href="http://localhost:1313/golang/foundation/">Go 语言基础知识</a></li>
<li class=""><a href="http://localhost:1313/golang/base/">Base</a></li>
</ul>
  
</li>

<li class=" has-sub-menu"><a href="http://localhost:1313/linux_foundation/">Linux基础<span class="mark closed">+</span></a>
  
<ul class="sub-menu">
<li class=""><a href="http://localhost:1313/linux_foundation/linux-commands/">50个常用Linux命令</a></li>
<li class=""><a href="http://localhost:1313/linux_foundation/cs_foundation/">计算机基础知识</a></li>
<li class=""><a href="http://localhost:1313/linux_foundation/linux-common/">Linux Common</a></li>
</ul>
  
</li>

<li class=" has-sub-menu"><a href="http://localhost:1313/exercise/">workout<span class="mark closed">+</span></a>
  
<ul class="sub-menu">
<li class=""><a href="http://localhost:1313/exercise/workout/">Workout</a></li>
</ul>
  
</li>

<li class=" has-sub-menu"><a href="http://localhost:1313/others/">others<span class="mark closed">+</span></a>
  
<ul class="sub-menu">
<li class=""><a href="http://localhost:1313/others/vc-news/">Vc News</a></li>
<li class=""><a href="http://localhost:1313/others/create-hugo-gitpage/">使用 Hugo 和 GitHub Pages 创建个人网站</a></li>
</ul>
  
</li>
</ul>
</nav>

 
<div class="sidebar-footer"></div>
</div>

</div><a href="#" id="backtothetop-fixed" class="backtothetop"
 data-backtothetop-duration="600"
 data-backtothetop-easing="easeOutQuart"
 data-backtothetop-fixed-fadeIn="1000"
 data-backtothetop-fixed-fadeOut="1000"
 data-backtothetop-fixed-bottom="10"
 data-backtothetop-fixed-right="20">
<span class="fa-layers fa-fw">
<i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i>
</span></a>
</div>
</body>
</html>
