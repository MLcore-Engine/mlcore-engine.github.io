/**
 * KaTeX Auto-Render Extension
 * Automatically renders math in text
 * v0.16.8
 */
(function(root, factory) {
  if (typeof define === 'function' && define.amd) {
    define(['katex'], factory);
  } else if (typeof module === 'object' && module.exports) {
    module.exports = factory(require('katex'));
  } else {
    root.renderMathInElement = factory(root.katex);
  }
}(typeof self !== 'undefined' ? self : this, function(katex) {
  'use strict';

  var renderMathInElement = function(elem, options) {
    if (!elem) {
      throw new Error("No element provided to render");
    }
    
    options = options || {};
    
    var delimiters = options.delimiters || [
      {left: "$$", right: "$$", display: true},
      {left: "\\(", right: "\\)", display: false},
      {left: "\\[", right: "\\]", display: true},
      {left: "$", right: "$", display: false}
    ];
    
    var ignoredTags = options.ignoredTags || ["script", "noscript", "style", "textarea", "pre", "code"];
    
    var renderOptions = options.renderOptions || {};

    // Find all math in the element and render it
    var mathElements = findMathInElement(elem, delimiters, ignoredTags);
    
    for (var i = 0; i < mathElements.length; i++) {
      var math = mathElements[i];
      try {
        renderMath(math.element, math.text, math.display, renderOptions);
      } catch (e) {
        console.error("Failed to render math: " + math.text, e);
      }
    }
  };

  function findMathInElement(element, delimiters, ignoredTags) {
    var mathElements = [];
    
    function processNode(node) {
      if (node.nodeType === 3) { // Text node
        var text = node.textContent;
        var mathFound = processMathInText(text, delimiters);
        
        if (mathFound.length > 0) {
          mathElements.push({
            element: node,
            text: mathFound[0].math,
            display: mathFound[0].display
          });
        }
      } else if (
        node.nodeType === 1 && // Element node
        ignoredTags.indexOf(node.nodeName.toLowerCase()) === -1
      ) {
        var childNodes = node.childNodes;
        for (var i = 0; i < childNodes.length; i++) {
          processNode(childNodes[i]);
        }
      }
    }
    
    processNode(element);
    return mathElements;
  }

  function processMathInText(text, delimiters) {
    var mathFound = [];
    
    for (var i = 0; i < delimiters.length; i++) {
      var delimiter = delimiters[i];
      var delimiterLength = delimiter.left.length;
      
      var startIndex = text.indexOf(delimiter.left);
      if (startIndex !== -1) {
        var endIndex = text.indexOf(delimiter.right, startIndex + delimiterLength);
        if (endIndex !== -1) {
          mathFound.push({
            math: text.substring(startIndex + delimiterLength, endIndex),
            display: delimiter.display
          });
        }
      }
    }
    
    return mathFound;
  }

  function renderMath(element, text, display, options) {
    var span = document.createElement('span');
    span.className = 'katex-math';
    span.textContent = text;
    span.style.display = display ? 'block' : 'inline';
    span.setAttribute('data-math-formula', text);
    element.parentNode.replaceChild(span, element);
  }

  return renderMathInElement;
})); 